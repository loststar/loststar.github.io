{"meta":{"title":"Loststar's blog","subtitle":"Stay hungry. Stay foolish.","description":"搞点薯条","author":"Loststar","url":"https://loststar.tech","root":"/"},"pages":[{"title":"关于我","date":"2022-02-17T09:13:13.976Z","updated":"2022-02-17T09:13:13.976Z","comments":true,"path":"about/index.html","permalink":"https://loststar.tech/about/index.html","excerpt":"","text":"我在看 实习 机会，主要看 后端，也想尝试 测开 Base 广东 最好，其他也没关系 大概可以3-6个月，全勤，有需要的大佬们可以联系我！ 邮箱：chenjintao1999#foxmail.com（#换成@） 这里是一个中二的Computer Science / Information Engineering 练习生 本科毕业于北京交通大学，硕士将要去香港中文大学，现在是 gap year 主要技术栈大约是 JAVA / Spring全家桶 / Redis / ElasticSearch 等 写过一点PHP和Go（抢课监控脚本），但都只是小工具 闲着没事的时候会搞些翻译玩玩，有尝试翻译和校对文章（记录 - 掘金翻译计划），也会参与翻译一些喜欢的软件：ISS Detector（最开始的翻译网站倒闭了，找不到记录了）和 Airport CEO（挺好玩的，翻译记录） 平时经常打电动，有时也会看看剧什么的。我一直觉得我不是二刺螈，但是我的B站已经六级了😂 最后，在线催更守望先锋2，还有感谢微软爸爸收购暴雪"},{"title":"分类","date":"2021-12-09T01:45:24.983Z","updated":"2021-12-09T01:45:24.983Z","comments":false,"path":"categories/index.html","permalink":"https://loststar.tech/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-09T01:44:30.134Z","updated":"2021-12-09T01:44:30.134Z","comments":false,"path":"tags/index.html","permalink":"https://loststar.tech/tags/index.html","excerpt":"","text":""},{"title":"陈锦涛-个人简介","date":"2017-09-26T14:24:01.000Z","updated":"2022-02-05T09:28:20.550Z","comments":false,"path":"about/cn/index.html","permalink":"https://loststar.tech/about/cn/index.html","excerpt":"","text":"个人信息 陈锦涛/男/1999 技术博客：https://loststar.tech Github：https://github.com/loststar 教育及工作经历 本科，北京交通大学，计算机与信息技术学院，计算机科学与技术专业，2017.9-至今 获得北京交通大学校级奖项3项，北京市级奖项1项。 语言能力 CET-4、CET-6 能够正常使用英语交流 可以流畅阅读英文文档 参与过英文技术文章翻译工作 翻译，通过“四不要”掌握 Python 中的 Lambda 函数（翻译记录） 校对，在 React 中使用 Service Worker（校对记录） 校对，微服务是你的最佳解决方案么？（校对记录） 校对，利用映射提高 MongoDB 性能（校对记录） 校对，使用 Rust 构建单页应用（校对记录） 校对，JavaScript 技巧 —— 子代构造函数，文本选择，内联 Workers 等等（校对记录） 校对，Python：使用 locals() 和 globals() 巧妙编程（校对记录） 参与过英文软件的本土化工作 ISS Detector，卫星追踪软件，翻译占比约90% Airport CEO，机场模拟游戏，翻译占比约15% 项目经历 负责人，基于全景图的三维布局重建，2020基于全景图实现三维漫游、场景内物品识别与推荐、场景分享等功能。本项目入选北京市大学生创新训练计划项目。我主要负责图像预处理、相似推荐、后台管理的实现 获奖经历 入选北京市大学生创新训练计划项目，2020 获得北京交通大学2018-2019学年“优秀团干部”，2019 获得2018年北京交通大学大学生数学建模竞赛三等奖，2018 获得北京交通大学第六届新生程序设计竞赛二等奖，2017 联系方式 邮箱：loststar.hj#gmail.com（#换成@）"},{"title":"chenjintao","date":"2017-09-26T14:24:01.000Z","updated":"2020-07-26T13:23:07.340Z","comments":false,"path":"about/en/index.html","permalink":"https://loststar.tech/about/en/index.html","excerpt":"","text":"个人信息 陈锦涛/男/1999 技术博客：https://loststar.tech Github：https://github.com/loststar 教育及工作经历 本科，北京交通大学，计算机与信息技术学院，计算机科学与技术专业，2017.9-至今 获得北京交通大学校级奖项3项，北京市级奖项1项。 语言能力 能够正常使用英语交流 可以流畅阅读英文文档 参与过英文技术文章翻译工作 校对，[译] JavaScript 技巧 —— 子代构造函数，文本选择，内联 Workers 等等（文章源仓库地址） 项目经历 负责人，基于全景图的三维布局重建，2020基于全景图实现三维漫游、场景内物品识别与推荐、场景分享等功能。本项目入选北京市大学生创新训练计划项目。我主要负责图像预处理、相似推荐、后台管理的实现 获奖经历 入选北京市大学生创新训练计划项目，2020 获得北京交通大学2018-2019学年“优秀团干部”，2019 获得2018年北京交通大学大学生数学建模竞赛三等奖，2018 获得北京交通大学第六届新生程序设计竞赛二等奖，2017 联系方式 邮箱： &#108;&#x6f;&#115;&#x74;&#115;&#x74;&#x61;&#114;&#x2e;&#104;&#106;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d; &#99;&#x68;&#101;&#x6e;&#106;&#x69;&#110;&#x74;&#x61;&#111;&#64;&#98;&#x6a;&#116;&#x75;&#46;&#x65;&#x64;&#117;&#46;&#x63;&#x6e; 微信：loststar9942"}],"posts":[{"title":"MIT 6.830 Lab 2: SimpleDB Operators","slug":"MIT-6-830-Lab-2-SimpleDB-Operators","date":"2022-02-16T02:00:25.000Z","updated":"2022-02-17T09:11:28.475Z","comments":true,"path":"posts/fba26ec9/","link":"","permalink":"https://loststar.tech/posts/fba26ec9/","excerpt":"","text":"其他 MIT 6.830 的实验记录请查看：Lab | MIT 6.830 | Loststar’s blog 课程官网：6.830/6.814: Database Systems (mit.edu) 框架代码仓库：MIT-DB-Class/simple-db-hw-2021 (github.com) 对应的单元测试： 练习 单元测试 Exercise 1 PredicateTest / JoinPredicateTest / FilterTest / JoinTest / FilterTest (systest) / JoinTest (systest) Exercise 1: Filter and JoinPredicate 系列通过对比字段运算结果筛选出符合要求的Tuple 实验涉及文件： src/java/simpledb/execution/Predicate.java src/java/simpledb/execution/JoinPredicate.java src/java/simpledb/execution/Filter.java src/java/simpledb/execution/Join.java Predicate比较： 调用Field的compare方法。 /** * Compares the field number of t specified in the constructor to the * operand field specified in the constructor using the operator specific in * the constructor. The comparison can be made through Field's compare * method. * * @param t The tuple to compare against * @return true if the comparison is true, false otherwise. */ public boolean filter(Tuple t) &#123; // some code goes here return t.getField(field).compare(op, operand); &#125; JoinPredicate比较： /** * Apply the predicate to the two specified tuples. The comparison can be * made through Field's compare method. * * @return true if the tuples satisfy the predicate. */ public boolean filter(Tuple t1, Tuple t2) &#123; // some code goes here return t1.getField(field1).compare(op, t2.getField(field2)); &#125; Filter开/关/重置： public void open() throws DbException, NoSuchElementException, TransactionAbortedException &#123; // some code goes here super.open(); child.open(); &#125; public void close() &#123; // some code goes here child.close(); super.close(); &#125; public void rewind() throws DbException, TransactionAbortedException &#123; // some code goes here child.rewind(); &#125; fetchNext： /** * AbstractDbIterator.readNext implementation. Iterates over tuples from the * child operator, applying the predicate to them and returning those that * pass the predicate (i.e. for which the Predicate.filter() returns true.) * * @return The next tuple that passes the filter, or null if there are no * more tuples * @see Predicate#filter */ protected Tuple fetchNext() throws NoSuchElementException, TransactionAbortedException, DbException &#123; // some code goes here while (child.hasNext()) &#123; Tuple tuple = child.next(); if (predicate.filter(tuple)) &#123; return tuple; &#125; &#125; return null; &#125; Join变量定义： 因为连接后的TupleDesc不止使用一次，就在这里定义了。 t1见后面fetchNext部分。 private JoinPredicate joinPredicate; private OpIterator child1; private OpIterator child2; private Tuple t1; private TupleDesc newTupleDesc; 构造方法： /** * Constructor. Accepts two children to join and the predicate to join them on * * @param p The predicate to use to join the children * @param child1 Iterator for the left(outer) relation to join * @param child2 Iterator for the right(inner) relation to join */ public Join(JoinPredicate p, OpIterator child1, OpIterator child2) &#123; // some code goes here this.joinPredicate = p; this.child1 = child1; this.child2 = child2; t1 = null; newTupleDesc = TupleDesc.merge(child1.getTupleDesc(), child2.getTupleDesc()); &#125; fetchNext方法： 注意： 外层循环不能使用while (child1.hasNext())，因为不是每次调用fetchNext的时候child1都需要取next。比如child1是[[1,2],[3,4]]，child2 是[[1,2,3],[2,3,4]]，假设所有组合都符合要求，第一个结果应该是[1,2,1,2,3]，而第二个结果是[1,2,2,3,4]。当选用错误的做法时，第二个会变成[3,4,1,2,3]。 因此，我们需要用成员变量t1储存当前值，当t2遍历一轮后，取下一个t1，并重置t2。 当单元测试出现expected tuple not found: 3 4 2 3 4 4提示时可以考虑是否存在这个问题。 /** * Returns the next tuple generated by the join, or null if there are no * more tuples. Logically, this is the next tuple in r1 cross r2 that * satisfies the join predicate. There are many possible implementations; * the simplest is a nested loops join. * &lt;p> * Note that the tuples returned from this particular implementation of Join * are simply the concatenation of joining tuples from the left and right * relation. Therefore, if an equality predicate is used there will be two * copies of the join attribute in the results. (Removing such duplicate * columns can be done with an additional projection operator if needed.) * &lt;p> * For example, if one tuple is &#123;1,2,3&#125; and the other tuple is &#123;1,5,6&#125;, * joined on equality of the first column, then this returns &#123;1,2,3,1,5,6&#125;. * * @return The next matching tuple. * @see JoinPredicate#filter */ protected Tuple fetchNext() throws TransactionAbortedException, DbException &#123; // some code goes here while (child1.hasNext() || t1 != null) &#123; if (child1.hasNext() &amp;&amp; t1 == null) &#123; t1 = child1.next(); &#125; int numT1 = t1.getTupleDesc().numFields(); while (child2.hasNext()) &#123; Tuple t2 = child2.next(); int numT2 = t2.getTupleDesc().numFields(); if (joinPredicate.filter(t1, t2)) &#123; Tuple t = new Tuple(newTupleDesc); for (int i = 0; i &lt; numT1; i++) &#123; t.setField(i, t1.getField(i)); &#125; for (int i = 0; i &lt; numT2; i++) &#123; t.setField(i + numT1, t2.getField(i)); &#125; return t; &#125; &#125; // child2 到尽头了，重新开始 child2.rewind(); t1 = null; &#125; return null; &#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"MIT 6.830","slug":"课程作业/MIT-6-830","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/MIT-6-830/"}],"tags":[{"name":"Database Systems","slug":"Database-Systems","permalink":"https://loststar.tech/tags/Database-Systems/"},{"name":"数据库","slug":"数据库","permalink":"https://loststar.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"loststar"},{"title":"MIT 6.830 Lab 1: SimpleDB","slug":"MIT-6-830-Lab-1-SimpleDB","date":"2022-02-12T10:19:34.000Z","updated":"2022-02-17T09:06:38.207Z","comments":true,"path":"posts/3c1ea5b1/","link":"","permalink":"https://loststar.tech/posts/3c1ea5b1/","excerpt":"","text":"其他 MIT 6.830 的实验记录请查看：Lab | MIT 6.830 | Loststar’s blog 课程官网：6.830/6.814: Database Systems (mit.edu) 框架代码仓库：MIT-DB-Class/simple-db-hw-2021 (github.com) 对应单元测试： 练习 单元测试 Exercise 1 TupleTest / TupleDescTest Exercise 2 CatalogTest Exercise 3 无 Exercise 4 HeapPageIdTest / RecordIDTest / HeapPageReadTest Exercise 5 HeapFileReadTest Exercise 6 / Lab 1 综合 ScanTest (systest) Exercise 1: Fields and TuplesTupleDesc 类似表头，包含了列的名称和类型。Tuple 则是每一行的数据。 实验涉及的文件： src/java/simpledb/storage/TupleDesc.java src/java/simpledb/storage/Tuple.java 实现比较简单，跟着注释完成就行。其中，hashCode 和 iterator 等方法主要参考了 ArrayList 的实现。 TupleDesc数据结构： 实验中，定义了一个辅助类TDItem，可以存储字段类型和字段名。因此，TupleDesc只需要实现一个可以储存TDItem的数组即可。 private TDItem[] tdItems; 迭代器： /** * TDItem 的迭代器类，参考 ArrayList */ private static class TDItr implements Iterator&lt;TDItem> &#123; private int cursor; private final TDItem[] tdItems; TDItr(TDItem[] tdItems) &#123; this.tdItems = tdItems; &#125; @Override public boolean hasNext() &#123; return cursor &lt; tdItems.length; &#125; @Override public TDItem next() &#123; int i = cursor; if (i >= tdItems.length) &#123; throw new NoSuchElementException(); &#125; cursor = i + 1; return tdItems[i]; &#125; &#125; /** * @return An iterator which iterates over all the field TDItems * that are included in this TupleDesc */ public Iterator&lt;TDItem> iterator() &#123; // some code goes here return new TDItr(tdItems); &#125; 相等判定： public boolean equals(Object o) &#123; // some code goes here if (o == this) &#123; return true; &#125; if (o instanceof TupleDesc) &#123; TupleDesc OtherTD = (TupleDesc) o; if (this.numFields() == OtherTD.numFields()) &#123; for (int i = 0; i &lt; this.numFields(); i++) &#123; if (!this.getFieldType(i).equals(OtherTD.getFieldType(i))) &#123; return false; &#125; &#125; return true; &#125; &#125; return false; &#125; hashCode： public int hashCode() &#123; // If you want to use TupleDesc as keys for HashMap, implement this so // that equal objects have equals hashCode() results // 参考 ArrayList int hashCode = tdItems.length; for (int i = 0; i &lt; tdItems.length; i++) &#123; TDItem e = tdItems[i]; hashCode = 31 * hashCode + (e == null ? 0 : e.fieldType.hashCode()); &#125; return hashCode; &#125; Tuple数据结构： private TupleDesc tupleDesc; private RecordId recordId; private Field[] fields; 迭代器： /** * @return An iterator which iterates over all the fields of this tuple */ public Iterator&lt;Field> fields() &#123; // some code goes here // 尝试匿名函数 return new Iterator&lt;Field>() &#123; private int cursor = 0; @Override public boolean hasNext() &#123; return cursor &lt; fields.length; &#125; @Override public Field next() &#123; int i = cursor; if (!hasNext()) &#123; throw new NoSuchElementException(); &#125; cursor = i + 1; return fields[i]; &#125; &#125;; &#125; Exercise 2: CatalogCatalog是数据库的目录，包含了各个表的信息。实验要求实现添加新表、获取表信息等功能。 实验涉及文件： src/java/simpledb/common/Catalog.java Catalog数据结构： 由于每张表都有file、name、pkeyField属性，于是创建Table类便于管理。实验中要求可以通过id来获取表信息，于是建立idTableMap。同时，还有根据name获取id的需求，于是建立nameIdMap。 private final ConcurrentHashMap&lt;Integer, Table> idTableMap; private final ConcurrentHashMap&lt;String, Integer> nameIdMap; /** * 辅助类，用于存储表信息 */ public static class Table &#123; private final DbFile file; private final String name; private final String pkeyField; public Table(DbFile file, String name, String pkeyField) &#123; this.file = file; this.name = name; this.pkeyField = pkeyField; &#125; public DbFile getFile() &#123; return file; &#125; public String getName() &#123; return name; &#125; public String getPkeyField() &#123; return pkeyField; &#125; @Override public String toString() &#123; return \"Table&#123;\" + \"file=\" + file + \", name='\" + name + '\\'' + \", pkeyField='\" + pkeyField + '\\'' + '&#125;'; &#125; &#125; 由表名获取id： 注意name要判空，否则过不了测试用例。 public int getTableId(String name) throws NoSuchElementException &#123; // some code goes here if (name == null || !nameIdMap.containsKey(name)) &#123; throw new NoSuchElementException(name + \"not found\"); &#125; return nameIdMap.get(name); &#125; 由id获取TupleDesc： 其他 get 方法大同小异 public TupleDesc getTupleDesc(int tableid) throws NoSuchElementException &#123; // some code goes here if (!idTableMap.containsKey(tableid)) &#123; throw new NoSuchElementException(tableid + \"not found\"); &#125; return idTableMap.get(tableid).getFile().getTupleDesc(); &#125; 删除所有： public void clear() &#123; // some code goes here idTableMap.clear(); nameIdMap.clear(); &#125; Exercise 3: BufferPoolBufferPool用于缓存读取过的页。在池未满时，将读取的页入池。池满后，每读取一次新页需要丢弃一次旧页。本次实验不需要实现置换策略，池满时抛出DbException即可。 实验涉及文件： src/java/simpledb/storage/BufferPool.java BufferPool数据结构： 需要根据PageId找页，以及判断池是否已满。于是创建&lt;PageId.hashCode, Page&gt;的Map用于缓存最近出现过的页。 private final ConcurrentHashMap&lt;Integer, Page> idPageMap; private int numPages; 获取页： 不需要实现置换策略，抛异常即可。 注意：Catalog是单例对象，调页时要用Database.getCatalog()获取。 public Page getPage(TransactionId tid, PageId pid, Permissions perm) throws TransactionAbortedException, DbException &#123; // some code goes here int id = pid.hashCode(); if (!idPageMap.containsKey(id)) &#123; if (idPageMap.size() >= numPages) &#123; throw new DbException(\"Buffer Pool Full\"); &#125; else &#123; DbFile databaseFile = Database.getCatalog().getDatabaseFile(pid.getTableId()); idPageMap.put(id, databaseFile.readPage(pid)); &#125; &#125; return idPageMap.get(id); &#125; Exercise 4: HeapPageHeapPage是页的一个实现，里面划分成许多slot，每个slot存放了一个的Tuple，还有一个header标记slot是否被使用。HeapPageId用于标识每个页面。RecordId用于标识每个Tuple。 实验涉及文件： src/java/simpledb/storage/HeapPageId.java src/java/simpledb/storage/RecordId.java src/java/simpledb/storage/HeapPage.java HeapPageId变量根据构造函数设计即可。都是些get方法。 hashCode： 因为注释提到可能用作HashMap的key，为了更好的分布，通过字符串的哈希来实现。 public int hashCode() &#123; // some code goes here String s = tableId + \",\" + pgNo; return s.hashCode(); &#125; RecordId变量同样是根据构造函数设计即可。 判定相等： public boolean equals(Object o) &#123; // some code goes here if (o == this) &#123; return true; &#125; if (o instanceof RecordId) &#123; RecordId other = (RecordId) o; if (this.pid.equals(other.pid) &amp;&amp; this.tupleno == other.tupleno) &#123; return true; &#125; &#125; return false; &#125; HeapPage元组数目计算：$$tuplesPerPage=\\lfloor \\frac{pageSize \\times 8}{tupleSize \\times 8+1} \\rfloor$$ 注意浮点运算！用8代替8.0的时候会有精度问题，过不了最后的ScanTest测试。喜欢乘1.0也可以。 /** * Retrieve the number of tuples on this page. * * @return the number of tuples on this page */ private int getNumTuples() &#123; // some code goes here int pageSize = BufferPool.getPageSize(); int tupleSize = td.getSize(); return (int) Math.floor((pageSize * 8.0) / (tupleSize * 8 + 1)); &#125; 计算 header 大小：$$headerSize=\\lceil \\frac{numSlots}{8} \\rceil$$ &#x2F;** * Computes the number of bytes in the header of a page in a HeapFile with each tuple occupying tupleSize bytes * * @return the number of bytes in the header of a page in a HeapFile with each tuple occupying tupleSize bytes *&#x2F; private int getHeaderSize() &#123; &#x2F;&#x2F; some code goes here return (int) Math.ceil(numSlots &#x2F; 8.0); &#125; 判断 slot 是否被使用： header是一个字节数组，每个字节有8位。因此在定位总的第i位时，需要找到它属于哪个字节，然后找到属于字节里的哪一位。$$\\begin{cases}byteIndex=i\\div8 \\\\bitIndex=i\\mod8 \\\\\\end{cases}$$其中，对2的次幂求模，可以用位运算代替取模运算以节省时间。这个在HashMap的实现里也有所体现。 /** * Returns true if associated slot on this page is filled. */ public boolean isSlotUsed(int i) &#123; // some code goes here int byteIndex = i >> 3; int bitIndex = i &amp; 7; return (header[byteIndex] >> bitIndex &amp; 1) == 1; &#125; 迭代器： hasNext判断是否存在下一个被使用的slot。 当调用remove方法时抛出UnsupportedOperationException。 /** * @return an iterator over all tuples on this page (calling remove on this iterator throws an UnsupportedOperationException) * (note that this iterator shouldn't return tuples in empty slots!) */ public Iterator&lt;Tuple> iterator() &#123; // some code goes here return new Iterator&lt;Tuple>() &#123; int cursor = 0; @Override public boolean hasNext() &#123; while (cursor &lt; numSlots &amp;&amp; !isSlotUsed(cursor)) &#123; cursor++; &#125; return cursor &lt; numSlots; &#125; @Override public Tuple next() &#123; int i = cursor; if (!hasNext()) &#123; throw new NoSuchElementException(); &#125; cursor = i + 1; return tuples[i]; &#125; @Override public void remove() &#123; throw new UnsupportedOperationException(\"remove\"); &#125; &#125;; &#125; Exercise 5: HeapFile这一节有两大任务：文件的随机读取和迭代器的实现。随机读取需要自行计算偏移量。迭代器实现需要考虑调页。 实验涉及文件： src/java/simpledb/storage/HeapFile.java HeapFile计算页面数目： /** * Returns the number of pages in this HeapFile. */ public int numPages() &#123; // some code goes here return (int) file.length() / BufferPool.getPageSize(); &#125; 页面读取： 这里，我们使用RandomAccessFile类来读取文件。构造函数中，第一个参数是文件，第二个参数是打开方式，这里使用的是只读。 首先判断页号是否合法，然后用seek方法定位到起始地址，用 read 方法读取一页。 读取完成后记得调用 close 方法。 // see DbFile.java for javadocs public Page readPage(PageId pid) &#123; // some code goes here int pageNumber = pid.getPageNumber(); int tableId = pid.getTableId(); int pageSize = BufferPool.getPageSize(); try &#123; RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\"); byte[] pageData = HeapPage.createEmptyPageData(); if (pageNumber >= numPages()) &#123; randomAccessFile.close(); throw new IllegalArgumentException(\"page not exist\"); &#125; try &#123; randomAccessFile.seek(pageNumber * pageSize); randomAccessFile.read(pageData, 0, pageSize); return new HeapPage(new HeapPageId(tableId, pageNumber), pageData); &#125; finally &#123; randomAccessFile.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; 迭代器： open 相当于初始化方法。hasNext 方法要判断本页是否读完，如果读完了要尝试调页而不是返回 false。rewind 的作用是重置迭代器，先close再open就行。 // see DbFile.java for javadocs public DbFileIterator iterator(TransactionId tid) &#123; // some code goes here return new DbFileIterator() &#123; private final BufferPool bufferPool = Database.getBufferPool(); private Iterator&lt;Tuple> pageTupleItr; private int curPage; // 调页工具方法 private HeapPage getPage(int pageNumber) throws DbException, TransactionAbortedException &#123; HeapPageId pageId = new HeapPageId(getId(), pageNumber); // 这个方法不用特别抛异常，DbException 和 TransactionAbortedException都是 getPage 抛的 HeapPage page = (HeapPage) bufferPool.getPage(tid, pageId, Permissions.READ_ONLY); return page; &#125; @Override public void open() throws DbException, TransactionAbortedException &#123; curPage = 0; pageTupleItr = getPage(0).iterator(); &#125; @Override public boolean hasNext() throws DbException, TransactionAbortedException &#123; if (pageTupleItr == null) &#123; return false; &#125; if (pageTupleItr.hasNext()) &#123; // 本页没读完 return true; &#125; else &#123; // 本页读完了，试图调下一非空页，直到最后一页 while (curPage + 1 &lt; numPages()) &#123; curPage += 1; HeapPage page = getPage(curPage); pageTupleItr = page.iterator(); if (pageTupleItr.hasNext()) &#123; return true; &#125; &#125; return false; &#125; &#125; @Override public Tuple next() throws DbException, TransactionAbortedException, NoSuchElementException &#123; if (pageTupleItr == null || !pageTupleItr.hasNext()) &#123; throw new NoSuchElementException(); &#125; return pageTupleItr.next(); &#125; @Override public void rewind() throws DbException, TransactionAbortedException &#123; close(); open(); &#125; @Override public void close() &#123; pageTupleItr = null; &#125; &#125;; &#125; Exercise 6: Operators在SimpleDB中，操作符是基于迭代器实现的。 实验涉及文件： src/java/simpledb/execution/SeqScan.java SeqScan变量定义： private TransactionId tid; private int tableid; private String tableAlias; private DbFileIterator dbFileIterator; 获取TupleDesc： 注意根据要求封装 /** * Returns the TupleDesc with field names from the underlying HeapFile, * prefixed with the tableAlias string from the constructor. This prefix * becomes useful when joining tables containing a field(s) with the same * name. The alias and name should be separated with a \".\" character * (e.g., \"alias.fieldName\"). * * @return the TupleDesc with field names from the underlying HeapFile, * prefixed with the tableAlias string from the constructor. */ public TupleDesc getTupleDesc() &#123; // some code goes here TupleDesc tupleDesc = Database.getCatalog().getTupleDesc(tableid); int numFields = tupleDesc.numFields(); Type[] types = new Type[numFields]; String[] fieldNames = new String[numFields]; for (int i = 0; i &lt; numFields; i++) &#123; types[i] = tupleDesc.getFieldType(i); fieldNames[i] = tableAlias + \".\" + tupleDesc.getFieldName(i); &#125; return new TupleDesc(types, fieldNames); &#125; 其余方法： 调用HeapFile的方法即可。 public void open() throws DbException, TransactionAbortedException &#123; // some code goes here Catalog catalog = Database.getCatalog(); DbFile databaseFile = catalog.getDatabaseFile(tableid); dbFileIterator = databaseFile.iterator(tid); dbFileIterator.open(); &#125; public boolean hasNext() throws TransactionAbortedException, DbException &#123; // some code goes here if (dbFileIterator != null) &#123; return dbFileIterator.hasNext(); &#125; return false; &#125; public Tuple next() throws NoSuchElementException, TransactionAbortedException, DbException &#123; // some code goes here if (dbFileIterator == null || !dbFileIterator.hasNext()) &#123; throw new NoSuchElementException(); &#125; return dbFileIterator.next(); &#125; public void close() &#123; // some code goes here dbFileIterator = null; &#125; public void rewind() throws DbException, NoSuchElementException, TransactionAbortedException &#123; // some code goes here close(); open(); &#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"MIT 6.830","slug":"课程作业/MIT-6-830","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/MIT-6-830/"}],"tags":[{"name":"Database Systems","slug":"Database-Systems","permalink":"https://loststar.tech/tags/Database-Systems/"},{"name":"数据库","slug":"数据库","permalink":"https://loststar.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"loststar"},{"title":"一种可扩容布隆过滤器设计","slug":"一种可扩容布隆过滤器设计","date":"2022-02-05T12:41:12.000Z","updated":"2022-02-14T12:54:21.881Z","comments":true,"path":"posts/cd44be17/","link":"","permalink":"https://loststar.tech/posts/cd44be17/","excerpt":"","text":"问题猜想上一篇文章，我们说到了怎么去实现简单的布隆过滤器，同时也提到了以下几个点： 布隆过滤器由于哈希冲突可能会存在误判； BitSet长度以及哈希函数的数目和冲突有关； BitSet长度以及哈希函数的数目由预计放入的元素数目和预期误判率计算得出。 从中，我们可以猜测：当实际放入过滤器中的元素多于预期时，布隆过滤器的效果会受到负面影响。 验证我们采用实际的误判率（误拒率，某一原本不在集合中的元素却被检测为在该集合中的概率）作为评价指标。预计放入的元素均为[0,n)的整数，每一组测试均使用[20000,23000)共3000个不在集合内的元素。 预计放入元素数目 预计误判率 实际放入元素数目 实际误判率 5000 0.01 4000 0.0003 5000 0.01 6000 0.0083 5000 0.01 8000 0.0427 5000 0.01 10000 0.1393 5000 0.01 20000 0.7573 预计放入元素数目 预计误判率 实际放入元素数目 实际误判率 5000 0.001 4000 0.0000 5000 0.001 6000 0.0007 5000 0.001 8000 0.0090 5000 0.001 10000 0.0357 5000 0.001 20000 0.5483 可以看到，超量加入元素的确对过滤器效果有较大影响。 方案在现实中，遇到这种超过预期的情况，最好的方法依然是重建过滤器。但是重建有一定的成本，不一定方便立刻重建。因此，可以设计扩容功能，短时间牺牲一些性能来保证准确率。在条件合适的时候再重建。 目前，对于扩容，一种比较不错的方法是并联多个过滤器，也就是使用多个BitSet。写入时，只在最新的过滤器写入；判断时，遍历各个过滤器，只要有一个判定存在则返回存在。 最后一个问题便是什么时候扩容。我认为，除了超过预计容量时需要扩容之外，应该设定一个扩容因子，当最新的布隆过滤器内1的比例超过该因子时，也要扩容。 实现变量static final int DEFAULT_INITIAL_CAPACITY = 1000; static final double DEFAULT_INITIAL_MISJUDGMENT_RATE = 0.01f; static final double DEFAULT_GROW_FACTOR = 0.5f; // 布隆过滤器列表 List&lt;BloomFilter> bloomFilters; // 最新的布隆过滤器 BloomFilter curBloomFilter; // 预计容量 int capacity; // 预计误判率 double misjudgmentRate; //当前容量 int size = 0; // 布隆过滤器数目 int numBloomFilter = 0; // 扩容因子(最新的布隆过滤器中1的比例) double growFactor = DEFAULT_GROW_FACTOR; 构造函数/** * 使用默认的元素个数(1000)、默认误判率(0.01)、默认扩容因子(0.5)构建一个布隆过滤器 * * @author: loststar * @time: 2022/2/5 21:56 */ public ScalableBloomFilter() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_INITIAL_MISJUDGMENT_RATE, DEFAULT_GROW_FACTOR); &#125; /** * 使用指定的元素个数、默认误判率(0.01)、默认扩容因子(0.5)构建一个布隆过滤器 * * @param capacity 元素个数 * @author: loststar * @time: 2022/2/5 21:58 */ public ScalableBloomFilter(int capacity) &#123; this(capacity, DEFAULT_INITIAL_MISJUDGMENT_RATE, DEFAULT_GROW_FACTOR); &#125; /** * 使用指定的元素个数、指定的误判率、默认扩容因子(0.5)构建一个布隆过滤器 * * @param capacity 元素个数 * @param misjudgmentRate 误判率 * @author: loststar * @time: 2022/2/5 21:58 */ public ScalableBloomFilter(int capacity, double misjudgmentRate) &#123; this(capacity, misjudgmentRate, DEFAULT_GROW_FACTOR); &#125; /** * 使用指定的元素个数、指定的误判率、指定的扩容因子构建一个布隆过滤器 * * @param capacity 元素个数 * @param misjudgmentRate 误判率 * @param growFactor 扩容因子 */ public ScalableBloomFilter(int capacity, double misjudgmentRate, double growFactor) &#123; this.capacity = capacity; this.misjudgmentRate = misjudgmentRate; bloomFilters = new ArrayList&lt;>(); grow(); &#125; 添加（关键）在这个函数内，我们先判断当前容量是否已经超过多个布隆过滤器的总容量，以及最新的布隆过滤器内1的占比是否超过扩容因子。如果需要扩容，则调用grow方法进行扩容，如果不需要则正常在最新的过滤器添加。 /** * 向布隆过滤器添加一个元素，同时判断是否需要扩容 * * @param value 要添加的元素 * @return: void * @author: loststar * @time: 2022/2/5 22:00 */ public void add(T value) &#123; if (size / numBloomFilter > capacity || curBloomFilter.calculateTrueBitProportion() > growFactor) &#123; grow(); &#125; size++; curBloomFilter.add(value); &#125; 扩容/** * 扩容函数 * * @author: loststar * @time: 2022/2/5 22:01 */ private void grow() &#123; curBloomFilter = new BloomFilter&lt;T>(capacity, misjudgmentRate); bloomFilters.add(curBloomFilter); numBloomFilter++; &#125; 判断判断每一个内是否存在 /** * 判断元素是否在布隆过滤器内 * * @param value 被判断的元素 * @return: boolean * @author: loststar * @time: 2022/2/5 22:00 */ public boolean contains(T value) &#123; for (BloomFilter bloomFilter : bloomFilters) &#123; if (bloomFilter.contains(value)) &#123; return true; &#125; &#125; return false; &#125; 测试测试前提同第一节，扩容因子均为0.5。 预计放入元素数目 预计误判率 实际放入元素数目 实际误判率 布隆过滤器数目 5000 0.01 4000 0.0003 1 5000 0.01 6000 0.0007 2 5000 0.01 8000 0.0010 2 5000 0.01 10000 0.0037 3 5000 0.01 20000 0.0070 5 预计放入元素数目 预计误判率 实际放入元素数目 实际误判率 布隆过滤器数目 5000 0.001 4000 0.0000 1 5000 0.001 6000 0.0003 2 5000 0.001 8000 0.0003 2 5000 0.001 10000 0.0003 3 5000 0.001 20000 0.0007 5 可以看到，准确率有较大幅度的提升。 对于时间消耗，本次并未测试。但是，根据设计，可以推测：对于添加方法，时间不变；对于判断方法，时间随着过滤器数目增多而增多。因此，本方法适合用作提高对错误估计的容忍程度，但不适合无限扩容。在合适的时候，仍需根据当前实际容量情况重新估计，并且重建过滤器。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://loststar.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"https://loststar.tech/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"Bloom Filter","slug":"Bloom-Filter","permalink":"https://loststar.tech/tags/Bloom-Filter/"},{"name":"扩容","slug":"扩容","permalink":"https://loststar.tech/tags/%E6%89%A9%E5%AE%B9/"}],"author":"loststar"},{"title":"布隆过滤器的学习与JAVA实现","slug":"布隆过滤器的学习与JAVA实现","date":"2022-02-01T08:24:25.000Z","updated":"2022-02-14T12:53:58.361Z","comments":true,"path":"posts/de1ff129/","link":"","permalink":"https://loststar.tech/posts/de1ff129/","excerpt":"","text":"扩展：一种可扩容布隆过滤器设计 什么是布隆过滤器这个问题网上一搜一大把，随便复制一段[维基百科](布隆过滤器 - 维基百科，自由的百科全书 (wikipedia.org))的解释：布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 在看了一段没什么意思的介绍后，来看看为什么它最大的特点： 布隆过滤器说这个对象不存在则一定不存在 布隆过滤器说这个对象不存在则一定不存在 布隆过滤器说这个对象不存在则一定不存在 布隆过滤器为什么能行如图，我们将全集（“张三”、“李四”）输入布隆过滤器。布隆过滤器对每个元素计算多次哈希（图中为3次）。建立一个BitSet记录每个哈希函数的结果：将结果对应的位设置为真（1）。 在验证阶段，与输入阶段一样，对每个待验证的元素计算多次哈希： 当任意一个哈希结果对应的位为假（0），则证明该元素没有出现过，不会误判。（图中“王五”） 当所有哈希结果对应的位均为真时，则认为是曾经被输入过。但是随着元素的增多，BitSet内真值密度增加，可能存在误判。（图中“赵六”） 布隆过滤器的参数选取在使用布隆过滤器之前，我们需要评估打算放入过滤器的元素数目n以及可以接受的误判率p。 需要的BitSet长度m和哈希函数个数k可以按照一下公式计算出来。$$m=\\frac{-n*ln(p) }{ (ln(2)^2)}$$ $$k=ln2*\\frac{m}{n}$$ 具体推导请看参考文献1和2。 如果想要在线计算的话，可以试试Bloom Filter Calculator (krisives.github.io) 简单的JAVA实现代码里有注释，大概可以明白？有不明白的请在评论留言，我看到后会立刻补上解释 主体package com.loststar.bloomfilter; import com.loststar.bloomfilter.hash.HashFunction; import com.loststar.bloomfilter.hash.MultiplyPrimeHash; import java.util.BitSet; public class BloomFilter&lt;T> &#123; static final int DEFAULT_INITIAL_CAPACITY = 1000; static final double DEFAULT_INITIAL_MISJUDGMENT_RATE = 0.01f; BitSet bitSet = null; int bitSetLength = 0; HashFunction hashFunctions = null; int numHashFunctions = 0; /** * 使用默认的元素个数(1000)和默认误判率(0.01)构建一个布隆过滤器 * * @author: loststar * @time: 2022/2/1 10:53 */ public BloomFilter() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_INITIAL_MISJUDGMENT_RATE); &#125; /** * 使用指定的元素个数和默认误判率(0.01)构建一个布隆过滤器 * * @param capacity * @author: loststar * @time: 2022/2/1 10:52 */ public BloomFilter(int capacity) &#123; this(capacity, DEFAULT_INITIAL_MISJUDGMENT_RATE); &#125; /** * 使用指定的元素个数和误判率构建一个布隆过滤器 * * @param capacity 过滤器内元素的个数 * @param misjudgmentRate 误判率 * @author: loststar * @time: 2022/2/1 10:45 */ public BloomFilter(int capacity, double misjudgmentRate) &#123; calculateLengthOfBitSet(capacity, misjudgmentRate); calculateNumHashFunctions(capacity); bitSet = new BitSet(bitSetLength); hashFunctions = new MultiplyPrimeHash(numHashFunctions); &#125; /** * 向布隆过滤器添加一个元素 * * @param value 要添加的元素 * @author: loststar * @time: 2022/2/1 11:09 */ public void add(T value) &#123; int[] hashArray = hashFunctions.hash(value); for (int hash : hashArray) &#123; bitSet.set(hash % bitSetLength); &#125; &#125; /** * 向布隆过滤器批量添加一组元素 * * @param values 包含要添加的元素的数组 * @author: loststar * @time: 2022/2/1 16:17 */ public void addAll(T[] values) &#123; for (T value : values) &#123; add(value); &#125; &#125; /** * 判断元素是否在布隆过滤器内 * * @param value 被判断的元素 * @return: boolean 元素是否在布隆过滤器内 * @author: loststar * @time: 2022/2/1 11:15 */ public boolean contains(T value) &#123; int[] hashArray = hashFunctions.hash(value); for (int hash : hashArray) &#123; if (!bitSet.get(hash % bitSetLength)) &#123; return false; &#125; &#125; return true; &#125; /** * 计算位数组的长度，m=-n*ln(p)/(ln2)^2 * * @param capacity 过滤器内元素的个数 * @param misjudgmentRate 误判率 */ public void calculateLengthOfBitSet(int capacity, double misjudgmentRate) &#123; this.bitSetLength = (int) Math.ceil(-capacity * Math.log(misjudgmentRate) / Math.pow(Math.log(2), 2)); &#125; /** * 计算位需要的函数个数，k=ln2*m/n * * @param capacity 过滤器内元素的个数 * @author: loststar * @time: 2022/2/1 10:56 */ public void calculateNumHashFunctions(int capacity) &#123; this.numHashFunctions = (int) Math.ceil(Math.log(2) * this.bitSetLength / capacity); &#125; /** * 计算bitset内1的占比 * * @return: double 1的比例 * @author: loststar * @time: 2022/2/1 13:12 */ public double calculateTrueBitProportion() &#123; return bitSet.cardinality() * 1.0 / bitSetLength; &#125; public int getBitSetLength() &#123; return bitSetLength; &#125; public int getNumberOfHashAlgorithm() &#123; return numHashFunctions; &#125; public int getCardinality() &#123; return bitSet.cardinality(); &#125; &#125; 哈希函数所有的哈希函数集合都会实现hash方法，用于计算key的numHashFunctions个哈希值，并返回。 package com.loststar.bloomfilter.hash; public abstract class HashFunction &#123; int[] hashResult; int numHashFunctions; public HashFunction(int numHashFunctions) &#123; this.numHashFunctions = numHashFunctions; hashResult = new int[numHashFunctions]; &#125; public abstract int[] hash(Object key); &#125; 这里使用的哈希函数思路来源于秦怀杂货店 - 掘金 (juejin.cn)和HahMap的哈希函数 package com.loststar.bloomfilter.hash; public class MultiplyPrimeHash extends HashFunction &#123; static final int[] PRIME_SEED = new int[]&#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113&#125;; public MultiplyPrimeHash(int numHashFunctions) &#123; super(numHashFunctions); &#125; public int[] hash(Object key) &#123; // 类似HashMap的实现，结果乘以seed int h; int res = (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); for (int i = 0; i &lt; numHashFunctions; i++) &#123; int curHash = res * PRIME_SEED[i]; // 取绝对值 hashResult[i] = (curHash ^ (curHash >> 31)) - (curHash >> 31); &#125; return hashResult; &#125; &#125; 现实中更广泛使用的还有MurmurHash等，感兴趣的可以看MurmurHash - Wikipedia。 测试测试指标这也算是个二分类问题，于是使用混淆矩阵作为评价。在参考文献6中可以找到相关的介绍。 测试过程先往布隆过滤器中添加0-9000，随后测试1000-6000（出现过）以及10000-13000（之前未输入）的预测情况。代码内truePositive、falsePositive、falseNegative、trueNegative的意义同样参见参考文献6。 public static void main(String[] args) &#123; BloomFilter&lt;Integer> bloomFilter = new BloomFilter&lt;>(15000, 0.001); int truePositive = 0, falsePositive = 0, falseNegative = 0, trueNegative = 0; for (int i = 0; i &lt; 9000; i++) &#123; bloomFilter.add(i); &#125; for (int i = 1000; i &lt; 6000; i++) &#123; if (bloomFilter.contains(i)) &#123; truePositive++; &#125; else &#123; falseNegative++; &#125; &#125; for (int i = 10000; i &lt; 13000; i++) &#123; if (!bloomFilter.contains(i)) &#123; trueNegative++; &#125; else &#123; falsePositive++; &#125; &#125; formattedOutput(bloomFilter, truePositive, falsePositive, falseNegative, trueNegative); &#125; 格式化打印结果public static void formattedOutput(BloomFilter bloomFilter, int truePositive, int falsePositive, int falseNegative, int trueNegative) &#123; System.out.println(\"---------------------Bloom Filter----------------------\"); System.out.println(\"*********布隆过滤器参数*********\"); System.out.println(\"数组长度：\" + bloomFilter.getBitSetLength()); System.out.println(\"函数个数：\" + bloomFilter.getNumberOfHashAlgorithm()); System.out.println(\"1的占比：\" + bloomFilter.calculateTrueBitProportion()); System.out.println(\"***********预测情况***********\"); System.out.println(truePositive + \"(TP) \" + falsePositive + \"(FP) \" + falseNegative + \"(FN) \" + trueNegative + \"(TN)\"); System.out.println(\"精确度：\" + truePositive * 1.0 / (truePositive + falsePositive)); System.out.println(\"正拒率/召回率：\" + truePositive * 1.0 / (truePositive + falseNegative)); System.out.println(\"误拒率：\" + falsePositive * 1.0 / (falsePositive + trueNegative)); &#125; 测试结果可以看到，当布隆过滤器认定元素未被输入时，结果一定可信（FN）。当布隆过滤器认定为曾经输入过时，有一定几率误判（FP），总体上符合预期。 ---------------------Bloom Filter---------------------- *********布隆过滤器参数********* 数组长度：215664 函数个数：10 1的占比：0.30474719934713257 ***********预测情况*********** 5000(TP) 26(FP) 0(FN) 2974(TN) 精确度：0.9948269001193792 正拒率&#x2F;召回率：1.0 误拒率：0.008666666666666666 进程已结束,退出代码0 参考文献 Bloom filter - Wikipedia Bloom Filters - the math (wisc.edu) algorithm - How many hash functions does my bloom filter need? - Stack Overflow 01ly/bloompy (github.com) 【实战问题】– 布隆过滤器的三种实践：手写，Redission以及Guava（2） - 掘金 (juejin.cn) 二分类模型评价标准：混淆矩阵 - 知乎 (zhihu.com)","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://loststar.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"https://loststar.tech/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"Bloom Filter","slug":"Bloom-Filter","permalink":"https://loststar.tech/tags/Bloom-Filter/"},{"name":"JAVA","slug":"JAVA","permalink":"https://loststar.tech/tags/JAVA/"},{"name":"造轮子","slug":"造轮子","permalink":"https://loststar.tech/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"}],"author":"loststar"},{"title":"对ThreadPoolTaskExecutor及其源码的观察","slug":"对ThreadPoolTaskExecutor及其源码的观察","date":"2022-01-04T15:37:02.000Z","updated":"2022-01-05T02:20:43.645Z","comments":true,"path":"posts/3be9af02/","link":"","permalink":"https://loststar.tech/posts/3be9af02/","excerpt":"","text":"实验概要在我的一个SpringBoot小项目中，用到了ThreadPoolTaskExecutor。对此，我有很多零碎的疑问，通过实践和查看源码逐一验证，记录在本文。实验中，Spring Framework版本为5.3.13。 实验对象ThreadPoolTaskExecutor是Spring提供的线程池，底层由ThreadPoolExecutor实现，参数与JAVA线程池类似，也提供了一些封装的方法，比如： public void setCorePoolSize(int corePoolSize) &#123; synchronized(this.poolSizeMonitor) &#123; if (this.threadPoolExecutor != null) &#123; this.threadPoolExecutor.setCorePoolSize(corePoolSize); &#125; this.corePoolSize = corePoolSize; &#125; &#125; 还有 public void setKeepAliveSeconds(int keepAliveSeconds) &#123; synchronized(this.poolSizeMonitor) &#123; if (this.threadPoolExecutor != null) &#123; this.threadPoolExecutor.setKeepAliveTime((long)keepAliveSeconds, TimeUnit.SECONDS); &#125; this.keepAliveSeconds = keepAliveSeconds; &#125; &#125; 实验方法对于有直观现象的问题，使用JMeter创建并发请求，使用jstack查看线程情况；对于无直观现象的、原理性的问题，直接查看其代码了解。 核心线程数可以为0吗?可以。 我们将核心线程数设置为0，最大线程数设置为20。 执行前 执行时 执行完成后再间隔空闲线程存活时间 可以看到，在执行任务时创建的线程在存活时间结束后全部被销毁，证明全部都是应急线程。 应急线程回收后剩下的是最初创建的几个线程吗？不一定。 我们将核心线程数设置为5，最大线程数设置为10。 首先，创建5个并发请求 执行完毕后，创建500个并发请求 等待KeepAliveSeconds秒后 可以看到，最后剩下的线程并不是最初创建的5个。 默认的阻塞队列是什么？视传入的任务队列的容量而定，当容量大于0为LinkedBlockingQueue，其他情况为SynchronousQueue 在不设置容量时，容量默认为2147483647。 protected BlockingQueue&lt;Runnable> createQueue(int queueCapacity) &#123; return (BlockingQueue)(queueCapacity > 0 ? new LinkedBlockingQueue(queueCapacity) : new SynchronousQueue()); &#125; 默认的拒绝策略是什么ThreadPoolTaskExecutor的默认拒绝策略和ThreadPoolTaskExecutor一致，为AbortPolicy，即丢弃线程任务并抛出异常。 private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();","categories":[{"name":"技术","slug":"技术","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/"},{"name":"项目记录","slug":"技术/项目记录","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://loststar.tech/tags/JAVA/"},{"name":"线程池","slug":"线程池","permalink":"https://loststar.tech/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"参数","slug":"参数","permalink":"https://loststar.tech/tags/%E5%8F%82%E6%95%B0/"},{"name":"jmeter","slug":"jmeter","permalink":"https://loststar.tech/tags/jmeter/"}],"author":"loststar"},{"title":"结合JDK源码学习单例模式","slug":"结合JDK源码学习单例模式","date":"2021-12-25T14:05:32.000Z","updated":"2021-12-26T04:28:39.501Z","comments":true,"path":"posts/ff220a60/","link":"","permalink":"https://loststar.tech/posts/ff220a60/","excerpt":"","text":"本文JDK源码基于JDK17 饿汉式使用static和final修饰实例变量，线程安全。但是可以被反射和反序列化破坏，以及如果一直不用会浪费内存。 基本实现public class Singleton &#123; private static final Singleton INSTANCE = new Singleton(); //关键：构造方法私有 private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return INSTANCE; &#125; public static void otherMethod() &#123;&#125; &#125; JDK中的饿汉式单例模式// java.lang.Runtime public class Runtime &#123; private static final Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; ...... &#125; 枚举简单，可以避免被反射和反序列化破坏。可以通过Singleton.INSTANCE直接调用。 基本实现enum Singleton &#123; INSTANCE; public static void otherMethod() &#123; &#125; &#125; JDK中的枚举单例模式// java.util.Comparators$NaturalOrderComparator enum NaturalOrderComparator implements Comparator&lt;Comparable&lt;Object>> &#123; INSTANCE; ...... &#125; 双重检测锁（DCL）懒汉式两次检查保证只调用一次创建对象的方法，提高了效率。 基本实现public class Singleton &#123; // 必须加volatile，防止指令重排序 private static volatile Singleton INSTANCE; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; // 第一次检查 if (INSTANCE == null) &#123; synchronized (Singleton.class) &#123; // 第二次检查 if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125; public void otherMethod() &#123;&#125; &#125; JDK中的DCL单例模式// java.lang.System public final class System &#123; ...... private static volatile Console cons; public static Console console() &#123; Console c; if ((c = cons) == null) &#123; synchronized (System.class) &#123; if ((c = cons) == null) &#123; cons = c = SharedSecrets.getJavaIOAccess().console(); &#125; &#125; &#125; return c; &#125; ...... &#125; 静态内部类基本实现利用jvm底层的类装载机制保证线程安全。 public class Singleton &#123; private Singleton() &#123;&#125; private static class InnerClass &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return InnerClass.INSTANCE; &#125; public static void otherMethod() &#123;&#125; &#125; JDK中的静态内部类单例模式// java.util.Collections public class Collections &#123; ...... private static class EmptyNavigableSet&lt;E> extends UnmodifiableNavigableSet&lt;E> implements Serializable &#123; ...... private static final NavigableSet&lt;?> EMPTY_NAVIGABLE_SET = new EmptyNavigableSet&lt;>(); ...... &#125; public static &lt;E> SortedSet&lt;E> emptySortedSet() &#123; return (SortedSet&lt;E>) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET; &#125; &#125; 不推荐使用的实现方式线程不安全的懒汉式public class Singleton &#123; private static Singleton INSTANCE; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; return INSTANCE; &#125; public void otherMethod() &#123;&#125; &#125; 使用同步方法的懒汉式效率非常低。 public class Singleton &#123; private static Singleton INSTANCE; private Singleton() &#123;&#125; // 在方法上加synchronized public static synchronized Singleton getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; return INSTANCE; &#125; public void otherMethod() &#123;&#125; &#125; 单检测锁懒汉式线程不安全。 public class Singleton &#123; private static Singleton INSTANCE; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Singleton.class) &#123; INSTANCE = new Singleton(); &#125; &#125; return INSTANCE; &#125; public void otherMethod() &#123;&#125; &#125; 参考 https://my.oschina.net/u/4372568/blog/4488503 https://www.hollischuang.com/archives/1383 https://www.bilibili.com/video/BV15b4y117RJ?p=62","categories":[{"name":"技术","slug":"技术","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"技术/java","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/java/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://loststar.tech/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"JDK","slug":"JDK","permalink":"https://loststar.tech/tags/JDK/"},{"name":"源码","slug":"源码","permalink":"https://loststar.tech/tags/%E6%BA%90%E7%A0%81/"}],"author":"loststar"},{"title":"计算二进制中1的个数","slug":"计算二进制中1的个数","date":"2021-12-20T11:39:24.000Z","updated":"2021-12-20T12:03:50.055Z","comments":true,"path":"posts/34ac3997/","link":"","permalink":"https://loststar.tech/posts/34ac3997/","excerpt":"","text":"相关题目：191. 位1的个数 - 力扣（LeetCode） 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 看题解时看到一种眼前一亮的方法：循环去掉最后一个1，计算循环次数。这种方法的核心在于如何高效去掉最后一个1，题解给出的方法是：n&amp;n-1。 如下图，n-1可以将n的最后一个1变为0，且将后面所有0变为1。将两数做按位与操作，则可高效去除最后一个1。","categories":[{"name":"算法","slug":"算法","permalink":"https://loststar.tech/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"loststar"},{"title":"引用不可变和对象不可变的例子","slug":"引用不可变和对象不可变的例子","date":"2021-12-14T08:43:01.000Z","updated":"2021-12-14T15:44:00.597Z","comments":true,"path":"posts/8bda9476/","link":"","permalink":"https://loststar.tech/posts/8bda9476/","excerpt":"","text":"对象不可变String s1=\"Hi\"; String s2=s1; System.out.println(\"操作前：\"); System.out.println(\"s1的内容：\"+s1+\" s2的内容：\"+s2); System.out.println(\"s1的hashcode：\"+s1.hashCode()+\",s2的hashcode：\"+s2.hashCode()); s1+=\" Loststar\"; System.out.println(\"操作后：\"); System.out.println(\"s1的内容：\"+s1+\" s2的内容：\"+s2); System.out.println(\"s1的hashcode：\"+s1.hashCode()+\",s2的hashcode：\"+s2.hashCode()); 结果： 操作前： s1的内容：Hi s2的内容：Hi s1的hashcode：2337,s2的hashcode：2337 操作后： s1的内容：Hi Loststar s2的内容：Hi s1的hashcode：746752949,s2的hashcode：2337 引用不可变用了final修饰变量 测试1： final StringBuilder sb = new StringBuilder(\"Hi\"); System.out.println(\"操作前：\"); System.out.println(\"sb的内容：\"+sb+\", sb的hashcode：\"+sb.hashCode()); sb.append(\" Loststar\"); System.out.println(\"操作后：\"); System.out.println(\"sb的内容：\"+sb+\", sb的hashcode：\"+sb.hashCode()); 结果： 操作前： sb的内容：Hi, sb的hashcode：2003749087 操作后： sb的内容：Hi Loststar, sb的hashcode：2003749087 测试2： final StringBuilder sb = new StringBuilder(\"Hi\"); sb=new StringBuilder(\"Hi Loststar\"); 结果报错：java: 无法为最终变量sb分配值","categories":[{"name":"技术","slug":"技术","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"技术/java","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/java/"}],"tags":[{"name":"对象不可变","slug":"对象不可变","permalink":"https://loststar.tech/tags/%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E5%8F%98/"},{"name":"引用不可变","slug":"引用不可变","permalink":"https://loststar.tech/tags/%E5%BC%95%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98/"}],"author":"loststar"},{"title":"Mark Text 初体验","slug":"Mark-Text-初体验","date":"2021-11-30T13:38:51.000Z","updated":"2021-12-14T15:41:34.825Z","comments":true,"path":"posts/5f3c13b2/","link":"","permalink":"https://loststar.tech/posts/5f3c13b2/","excerpt":"","text":"一觉醒来，发现Typora要收费了。虽然依然能用旧版，但是感觉一直用旧版也不是个办法。再加上个人感觉Typora目前没有特别多值得付费的功能，就打算先找个代替品，继续观望。以后要是有很coooooooooool的功能再考虑付费支持。 下载地址官网：https://marktext.app/ Github： 这次尝试的版本是v0.16.3 体验到的功能标签页看到标签页直接泪目。这就是梦中的编辑器吗？ 印象里这个功能是默认打开的，如果没有，勾选View-&gt;Show Tab Bar就行了。 在编辑界面，使用Ctrl+TAB可以切换标签。 主题目前有6个主题，其中3个是亮色三个是暗色。 我使用的是Material Dark 表情包使用Ctrl+/可以呼出表情包面板，可以根据关键词搜索表情包。 搜索框还有随机功能，可以搜索随机关键词。然而这个词库可能被调教坏了： 比较难顶的地方点击大纲不会跳转！！！！！！ 后记至此，我觉得Mark Text基本能满足我的使用场景。当然，还有很多功能和设置我还没体验过。我已经将默认的markdown编辑器改为Mark Text，往后在写东西的过程中再慢慢体验。","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://loststar.tech/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://loststar.tech/tags/markdown/"},{"name":"marktext","slug":"marktext","permalink":"https://loststar.tech/tags/marktext/"}],"author":"loststar"},{"title":"排序复习","slug":"排序复习","date":"2021-11-28T13:57:26.000Z","updated":"2022-02-17T09:13:13.964Z","comments":true,"path":"posts/e45aa11e/","link":"","permalink":"https://loststar.tech/posts/e45aa11e/","excerpt":"","text":"更多请参考： Sorting algorithm - Wikipedia 排序算法 - 维基百科，自由的百科全书 中英文内容略有差别，其中中文没有最好情况，但是在复杂度、稳定性的比较中考虑了是用数组还是链表存储。 复杂度及稳定性 排序方式 平均时间复杂度 最好时间复杂度 最坏时间复杂度 辅助空间 稳定性 冒泡排序 O(n^2) O(n) O(n^2) O(1) 稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 插入排序 O(n^2) O(n) O(n^2) O(1) 稳定 希尔排序 O(n^(4/3)) O(nlogn) O(n^(3/2)) O(1) 不稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 实现抽象类所有排序类继承于抽象类Sort import java.util.Arrays; public abstract class Sort &#123; protected int[] nums; public Sort(int[] nums) &#123; this.nums = nums; &#125; public void printNums(int i) &#123; System.out.println(\"第\"+i+\"轮循环后：\"+ Arrays.toString(nums)); &#125; public abstract int[] sort(boolean isDebug); &#125; 其中，nums数组用于存放被排序的数；sort方法用于实现排序，其中参数isDebug用于声明是否输出每一轮的结果； printNums方法用于打印排序中间结果。 冒泡排序传统冒泡排序public class BubbleSort extends Sort &#123; public BubbleSort(int[] nums) &#123; super(nums); &#125; @Override public int[] sort(boolean isDebug) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = 0; j &lt; nums.length - 1 - i; j++) &#123; if (nums[j] > nums[j + 1]) &#123; swap(j, j + 1); &#125; &#125; if (isDebug) &#123; printNums(i); &#125; &#125; return nums; &#125; public void swap(int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; &#125; 记忆最后更改位置的冒泡排序public class NewBubbleSort extends Sort &#123; public NewBubbleSort(int[] nums) &#123; super(nums); &#125; @Override public int[] sort(boolean isDebug) &#123; int compareTimes = nums.length - 1; for (int i = 0; i &lt; nums.length - 1; i++) &#123; int lastCompare = 0; for (int j = 0; j &lt; compareTimes; j++) &#123; if (nums[j] > nums[j + 1]) &#123; swap(j, j + 1); lastCompare = j; &#125; &#125; compareTimes = lastCompare; if (isDebug) &#123; printNums(i); &#125; if (lastCompare == 0) &#123; break; &#125; &#125; return nums; &#125; public void swap(int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; &#125; 选择排序public class SelectionSort extends Sort &#123; public SelectionSort(int[] nums) &#123; super(nums); &#125; @Override public int[] sort(boolean isDebug) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; int minNumber = nums[i]; int placeOfMinNumber = i; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] &lt; minNumber) &#123; minNumber = nums[j]; placeOfMinNumber = j; &#125; &#125; swap(i, placeOfMinNumber); if (isDebug) printNums(i); &#125; return nums; &#125; public void swap(int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; &#125; 插入排序public class InsertSort extends Sort&#123; public InsertSort(int[] nums) &#123; super(nums); &#125; @Override public int[] sort(boolean isDebug) &#123; for(int i=1;i&lt;nums.length;i++) &#123; int isSorted=i-1; int thisNum=nums[i]; while (isSorted>=0) &#123; if(thisNum&lt;nums[isSorted]) &#123; nums[isSorted+1]=nums[isSorted]; isSorted--; &#125; else &#123; break; &#125; &#125; nums[isSorted+1]=thisNum; if(isDebug) printNums(i); &#125; return nums; &#125; &#125; 希尔排序public class ShellSort extends Sort &#123; private StepListType stepListType; public enum StepListType &#123; //https://en.wikipedia.org/wiki/Shellsort SHELL, FRANK_LAZARUS, HIBBARD &#125; public ShellSort(int[] nums, StepListType stepListType) &#123; super(nums); this.stepListType = stepListType; &#125; @Override public int[] sort(boolean isDebug) &#123; int length = nums.length; List&lt;Integer> stepList = generateStepList(length, this.stepListType); for (int step : stepList) &#123; for (int i = step; i &lt; length; i++) &#123; int isSorted = i - step; int thisNum = nums[i]; while (isSorted >= 0 &amp;&amp; thisNum &lt; nums[isSorted]) &#123; nums[isSorted + step] = nums[isSorted]; isSorted -= step; &#125; nums[isSorted + step] = thisNum; if (isDebug) &#123; this.printNums(step, i - step); &#125; &#125; &#125; return nums; &#125; public List&lt;Integer> generateStepList(int length, StepListType type) &#123; //生成步长 switch (type) &#123; case SHELL -> &#123; List&lt;Integer> list = new ArrayList&lt;>(); int step = length; //必须 while (step != 1) &#123; step = (int) Math.floor(step / 2); list.add(step); &#125; return list; &#125; case FRANK_LAZARUS -> &#123; List&lt;Integer> list = new ArrayList&lt;>(); int k = 1; int step = length; //没啥意义，大于1就行 while (step != 1) &#123; step = (int) (2 * Math.floor(length / Math.pow(2, k + 1)) + 1); list.add(step); k++; &#125; return list; &#125; case HIBBARD -> &#123; List&lt;Integer> list = new ArrayList&lt;>(); int step = 1; int k = 1; while (step &lt; length) &#123; list.add(step); k++; step = (int) (Math.pow(2, k) - 1); &#125; Collections.reverse(list); return list; &#125; &#125; return Collections.EMPTY_LIST; &#125; public void printNums(int step, int i) &#123; System.out.println(\"步长为\" + step + \"的第\" + i + \"轮循环后：\" + Arrays.toString(nums)); &#125; &#125; 快速排序import java.util.Arrays; public class QuickSort extends Sort &#123; public QuickSort(int[] nums) &#123; super(nums); &#125; public int Partition(int low, int high) &#123; int pivotKey = nums[high]; int i = low; for (int j = low; j &lt; high; j++) &#123; if (nums[j] &lt; pivotKey) &#123; swap(i, j); i++; &#125; &#125; swap(i, high); return i; &#125; public void RealQuickSort(int low, int high, boolean isDebug, int recursionDepth) &#123; //如果不需要打印分步之类的信息，保留low/high就行了 if (low &lt; high) &#123; int pivotLoc = Partition(low, high); if (isDebug) &#123; this.printNums(recursionDepth); &#125; RealQuickSort(low, pivotLoc - 1, isDebug, recursionDepth + 1); RealQuickSort(pivotLoc + 1, high, isDebug, recursionDepth + 1); &#125; &#125; @Override public int[] sort(boolean isDebug) &#123; RealQuickSort(0, nums.length - 1, isDebug, 0); return nums; &#125; public void swap(int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; public void printNums(int recursionDepth) &#123; System.out.println(\"递归深度为\" + recursionDepth + \"时：\" + Arrays.toString(nums)); &#125; &#125; 堆排序public class HeapSort extends Sort &#123; public HeapSort(int[] nums) &#123; super(nums); &#125; private void heaptify(int parent, int length) &#123; int temp = nums[parent]; int child = 2 * parent + 1; // 左孩子 while (child &lt; length) &#123; if (child + 1 &lt; length &amp;&amp; nums[child] &lt; nums[child + 1]) &#123; // 选左右孩子更大那个 child = child + 1; //右孩子更大 &#125; if (temp >= nums[child]) &#123; break; &#125; nums[parent] = nums[child]; parent = child; //从上而下调整 child = 2 * child + 1; &#125; nums[parent] = temp; &#125; public void buildHeap() &#123; int length = nums.length; for (int i = length / 2 - 1; i >= 0; i--) &#123; // 从右往左，从下往上,从最右下的非叶子节点开始 heaptify(i, length); &#125; &#125; @Override public int[] sort(boolean isDebug) &#123; int length = nums.length; buildHeap(); for (int i = length - 1; i > 0; i--) &#123; // n-1次循环 swap(0, i); //第一个元素和未排序的最后一个交换 heaptify(0, i); if (isDebug) &#123; printNums(i); &#125; &#125; return nums; &#125; &#125; 分类总结稳定性稳定： 冒泡排序、插入排序 不稳定： 选择排序、快速排序、希尔排序、堆排序 平均时间复杂度O(n^2)： 冒泡排序、选择排序、插入排序 O(nlogn)： 快速排序、堆排序 O(n^(4/3))： 希尔排序 辅助空间O(1)： 冒泡排序、选择排序、插入排序、堆排序 O(logn)： 快速排序","categories":[{"name":"算法","slug":"算法","permalink":"https://loststar.tech/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://loststar.tech/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"插入排序","slug":"插入排序","permalink":"https://loststar.tech/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","permalink":"https://loststar.tech/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"}],"author":"loststar"},{"title":"hexo文章内折叠插件","slug":"hexo文章内折叠插件","date":"2021-11-28T13:48:48.000Z","updated":"2021-12-14T15:40:49.495Z","comments":true,"path":"posts/174f11e7/","link":"","permalink":"https://loststar.tech/posts/174f11e7/","excerpt":"","text":"通过使用该插件可以实现文章内容的折叠： 使用方法&#123;% spoiler \"标题\" %&#125; 内容 &#123;% endspoiler %&#125; 演示 我是标题 我是内容 //我是代码 System.out.println(\"hi\");","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://loststar.tech/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://loststar.tech/tags/%E6%8F%92%E4%BB%B6/"},{"name":"折叠","slug":"折叠","permalink":"https://loststar.tech/tags/%E6%8A%98%E5%8F%A0/"}],"author":"loststar"},{"title":"通过merge方法实现HashMap的value自增","slug":"通过merge方法实现HashMap的value自增","date":"2021-11-19T15:58:23.000Z","updated":"2021-12-14T15:44:51.591Z","comments":true,"path":"posts/5f2205e5/","link":"","permalink":"https://loststar.tech/posts/5f2205e5/","excerpt":"","text":"解决问题在水leetcode的时候，想要实现map里指定key对应的value自增的功能。 最开始想到的是之前经常使用的写法： myMap.put(myKey,myMap.containsKey(myKey)?myMap.get(myKey)+1:1); 忽然想到前几天看到的merge方法，决得应该会实现得更优雅。搜索发现果然可以： myMap.merge(myKey, 1, Integer::sum); Map.merge()在java.util.Map可以找到merge方法的源码： default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V> remappingFunction) &#123; Objects.requireNonNull(remappingFunction); Objects.requireNonNull(value); V oldValue = get(key); V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value); if (newValue == null) &#123; remove(key); &#125; else &#123; put(key, newValue); &#125; return newValue; &#125; 可以看到，merge的作用就是：1. 当value参数空时，删除key对应的键值对；2. 判断是否有对应的key，如果没有，插入(key, value)；3. 如果原来有对应的key，根据旧值与value计算出新值，插入(key, newValue)。 Integer::sumpublic static int sum(int a, int b) &#123; return a + b; &#125; 参考 [Java基础]让Map value自增 - 安琪拉的博客(公众号) - 博客园 别再这么写代码了，这几个方法不香吗？ - 楼下小黑哥 - 博客园","categories":[{"name":"技术","slug":"技术","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"技术/java","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/java/"}],"tags":[{"name":"map","slug":"map","permalink":"https://loststar.tech/tags/map/"},{"name":"merge","slug":"merge","permalink":"https://loststar.tech/tags/merge/"}],"author":"loststar"},{"title":"PasteEx，将剪贴板粘贴为文件的工具","slug":"PasteEx，将剪贴板粘贴为文件的工具","date":"2021-07-20T01:37:54.000Z","updated":"2021-12-14T15:40:18.486Z","comments":true,"path":"posts/259390eb/","link":"","permalink":"https://loststar.tech/posts/259390eb/","excerpt":"","text":"在写作业的时候，经常需要保存一些截图。最开始的解决方法是截图后打开画图，然后保存。在使用了 PasteEx 之后，只需直接在想保存的地方右键即可保存。剪贴板内的文字同理也可以直接保存为txt文件，不需要打开其他程序。","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://loststar.tech/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"剪贴板","slug":"剪贴板","permalink":"https://loststar.tech/tags/%E5%89%AA%E8%B4%B4%E6%9D%BF/"},{"name":"一键保存","slug":"一键保存","permalink":"https://loststar.tech/tags/%E4%B8%80%E9%94%AE%E4%BF%9D%E5%AD%98/"}],"author":"loststar"},{"title":"数据结构实验3—-数组与广义表","slug":"数据结构实验3—-数组与广义表","date":"2021-03-23T00:38:11.000Z","updated":"2021-11-23T01:57:27.748Z","comments":true,"path":"posts/5a6e9197/","link":"","permalink":"https://loststar.tech/posts/5a6e9197/","excerpt":"","text":"本系列文章广泛借鉴了各种教材和博客文章，由于完成时间比较久远，如果有遗漏标注的请联系我补充或删除解答。本文中解答仅供参考学习。 鞍点问题题目若矩阵A中的某一元素A[i,j]是第i行中的最小值，而又是第j列中的最大值，则称A[i,j]是矩阵A中的一个鞍点。写出一个可以确定鞍点位置的程序。 解答#include&lt;stdio.h> #define m 3 #define n 3 int arr[m][n] = &#123; //矩阵 30,40,11, 2,5,6, 1,8,9 &#125;; int main() &#123; for (int i = 0; i &lt; m; i++) &#123; int dstI = i, dstJ = 0; int minX = arr[i][0]; //找第i行的最小值(dstX,dstY) for (int j = 0; j &lt; n; j++) &#123; if (arr[i][j] &lt; minX) &#123; minX = arr[i][j]; dstI = i; dstJ = j; &#125; &#125; int maxY = arr[dstI][dstJ],flag=1; //遍历dstJ列，查找有没有比arr[dstI][dstJ]大的数 for (int j = 0; j &lt; m; j++) &#123; if (arr[j][dstJ] > maxY) &#123; flag = 0; break; &#125; &#125; if (flag == 1) &#123; flag = 0; printf(\"(%d,%d)\", dstI, dstJ); &#125; &#125; &#125; 运行结果得到鞍点。在上文提到的测试矩阵中是(0,2)。 稀疏矩阵转置题目输入稀疏矩阵中每个元素的行号、列号、值，建立稀疏矩阵的三元组存储结构，并将此矩阵转置，显示转置前后的三元组结构。 解答#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h> #define MAXSIZE 12500 typedef struct &#123; int i, j; //该非零元的行下标和列下标 int value; // 该非零元的值 &#125; Triple; // 三元组类型 typedef struct &#123; Triple data[MAXSIZE + 1]; int iTot; int jTot; int numTot; //行数，列数，非零元个数 &#125; TSMatrix; // 稀疏矩阵类型 int TransposeSMatrix(TSMatrix M, TSMatrix &amp;T) &#123; T.iTot = M.jTot; T.jTot = M.iTot; T.numTot = M.numTot; int q = 1; if (T.numTot!=0) &#123; for (int col = 1; col &lt;= M.jTot; col++) &#123; for (int p = 1; p &lt;= M.numTot; p++) &#123; if (M.data[p].j == col) &#123; T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i; T.data[q].value = M.data[p].value; q++; &#125; &#125; &#125; &#125; return 0; &#125; int ShowSMatrix(TSMatrix M) &#123; int p = 1; for (int i = 1; i &lt;= M.iTot; i++) &#123; for (int j = 1; j &lt;= M.jTot; j++) &#123; if (M.data[p].i == i &amp;&amp; M.data[p].j == j) &#123; printf(\"%d \", M.data[p].value); p++; &#125; else &#123; printf(\"0 \"); &#125; &#125; printf(\"\\n\"); &#125; return 0; &#125; int main() &#123; TSMatrix M, T; int a, b, c; printf(\"行数、列数、非零元个数：\\n\"); scanf(\"%d %d %d\", &amp;M.iTot, &amp;M.jTot, &amp;M.numTot); for (int temp = 1; temp &lt;= M.numTot; temp++) &#123; scanf(\"%d %d %d\", &amp;M.data[temp].i, &amp;M.data[temp].j, &amp;M.data[temp].value); &#125; printf(\"转置前\\n\"); ShowSMatrix(M); TransposeSMatrix(M, T); printf(\"转置后\\n\"); ShowSMatrix(T); &#125; 运行结果 广义表题目用头尾链表存储表示法建立广义表，输出广义表，求广义表的表头、广义表的表尾和广义表的深度。 解答 这题我当时不会，大部分对着博客（广义表的创建 喜爱兰兰-CSDN博客 创建广义表）学然后默写调通。现在把默写部分替换回原作者带有清晰注释的部分。求深度部分来自严蔚敏《数据结构》。 #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #define MAX_STR_LEN 100 typedef char AtomType; typedef enum &#123; ATOM, LIST &#125; ElemTag; &#x2F;&#x2F; ATOM&#x3D;&#x3D;0:原子, LIST&#x3D;&#x3D;1:子表 typedef struct GLNode &#123; ElemTag tag; &#x2F;&#x2F; 标志域 union &#123; AtomType atom; &#x2F;&#x2F; 原子结点的数据域 struct &#123; struct GLNode *hp, *tp; &#125; ptr; &#125;; &#125; *GList; char hstr[MAX_STR_LEN], istr[MAX_STR_LEN]; void SubString(char *substr, char *inputstr, int start, int end) &#123; &#x2F;&#x2F;截取字符串中间内容，本程序中主要用于去头尾括号 for (char *temp &#x3D; inputstr + start; temp &lt;&#x3D; inputstr + end; temp++) &#123; *substr &#x3D; *temp; *substr++; &#125; *substr &#x3D; &#39;\\0&#39;; &#125; void SplitHeadStr(char *&amp;inputstr, char *&amp;headstr) &#123; &#x2F;&#x2F;将非空串inputstr分割成两个部分，headstr为第一个&#39;,&#39;之前的子串，inputstr为之后的字串 int n &#x3D; strlen(inputstr); int i &#x3D; 0; int k &#x3D; 0; &#x2F;&#x2F;记录尚为配对的左括号的个数 do &#123; &#x2F;&#x2F;找出最高层头尾分隔点 &#x2F;&#x2F;由于字符串最外面没有括号，所以找到逗号的时候左右括号数应该相等，否则不是最高层 if (inputstr[i] &#x3D;&#x3D; &#39;(&#39;) k++; else if (inputstr[i] &#x3D;&#x3D; &#39;)&#39;) k--; i++; &#125; while (i &lt; n &amp;&amp; (inputstr[i] !&#x3D; &#39;,&#39; || k !&#x3D; 0)); if (i &lt; n) &#123; SubString(headstr, inputstr, 0, i - 1); SubString(inputstr, inputstr, i + 1, strlen(inputstr) - 1); &#125; else &#123; strcpy(headstr, inputstr); inputstr &#x3D; &#39;\\0&#39;; &#125; &#125; int CreateGList(GList &amp;L, char *s) &#123; if (strcmp(s, &quot;()&quot;) &#x3D;&#x3D; 0) L &#x3D; NULL; &#x2F;&#x2F;建立空表 else &#123; L &#x3D; (GList)malloc(sizeof(struct GLNode)); &#x2F;&#x2F;新建一个表结点 if (L &#x3D;&#x3D; NULL) return -1; if (strlen(s) &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F;原子结点 L-&gt;tag &#x3D; ATOM;; L-&gt;atom &#x3D; *s; &#125; else &#123; char *headstr &#x3D; hstr; L-&gt;tag &#x3D; LIST; SubString(s, s, 1, strlen(s) - 2); &#x2F;&#x2F;脱去最外边的括号 GList pointer &#x3D; L; do &#123; &#x2F;&#x2F;创建子表 SplitHeadStr(s, headstr); &#x2F;&#x2F;headstr为分割后的表头，s为分割后的表尾 char tstr[MAX_STR_LEN]; strcpy(tstr, headstr); CreateGList(pointer-&gt;ptr.hp, tstr); &#x2F;&#x2F;递归创建表头 if (s !&#x3D; NULL &amp;&amp; strlen(s) !&#x3D; 0) &#123; &#x2F;&#x2F;如果表尾不为空的话 GList tailnode &#x3D; (GList)malloc(sizeof(struct GLNode)); if (pointer &#x3D;&#x3D; NULL) return -1; tailnode-&gt;tag &#x3D; LIST; &#x2F;&#x2F;广义表的表尾肯定是一张表 pointer-&gt;ptr.tp &#x3D; tailnode; pointer &#x3D; tailnode; &#125; &#125; while (s !&#x3D; NULL &amp;&amp; strlen(s) !&#x3D; 0); &#x2F;&#x2F;直到表尾为空NULL则退出 pointer-&gt;ptr.tp &#x3D; NULL; &#x2F;&#x2F;最后将表尾赋值为NULL &#125; &#125; return 0; &#125; void PrintGList(const GList L) &#123; printf(&quot;(&quot;); GList pointer &#x3D; L; do &#123; GList temp &#x3D; pointer-&gt;ptr.hp; if (temp !&#x3D; NULL) &#123; &#x2F;&#x2F;递归输出表头中原子结点 if (temp-&gt;tag &#x3D;&#x3D; ATOM) &#123; printf(&quot;%c&quot;, temp-&gt;atom); &#125; else &#123; PrintGList(temp); &#125; &#125; if (pointer-&gt;ptr.tp !&#x3D; NULL) &#123; &#x2F;&#x2F;后面还有 printf(&quot;,&quot;); &#125; pointer &#x3D; pointer-&gt;ptr.tp; &#x2F;&#x2F; 指针指向表尾,判断表尾是否空 &#125; while (pointer !&#x3D; NULL); printf(&quot;)&quot;); &#125; int GetGListDepth(GList L) &#123; if (!L) return 1;&#x2F;&#x2F;空表 if (L-&gt;tag &#x3D;&#x3D; ATOM) return 0;&#x2F;&#x2F;原子 int max &#x3D; 0; for (GList pp &#x3D; L; pp; pp &#x3D; pp-&gt;ptr.tp) &#123; int dep &#x3D; GetGListDepth(pp-&gt;ptr.hp); if (dep &gt; max) &#123; max &#x3D; dep;&#x2F;&#x2F;每次找到表中遍历到深度最大的表，并用max记录 &#125; &#125; return max + 1; &#125; int main() &#123; char s[100]; scanf(&quot;%s&quot;, &amp;s); int left &#x3D; 0, right &#x3D; 0; for (int i &#x3D; 0; i &lt; strlen(s); i++) &#123; if (s[i] &#x3D;&#x3D; &#39;(&#39;) left++; if (s[i] &#x3D;&#x3D; &#39;)&#39;) right++; &#125; if (left !&#x3D; right) &#123; printf(&quot;error&quot;); return -1; &#125; strcpy(istr, s); GList L; char *head&#x3D;(char*)malloc(MAX_STR_LEN*sizeof(char)), *tail&#x3D;(char*)malloc(MAX_STR_LEN * sizeof(char)); strcpy(tail, istr); CreateGList(L, istr); SubString(tail, tail, 1, strlen(tail) - 2); printf(&quot;广义表:&quot;); PrintGList(L); SplitHeadStr(tail, head); printf(&quot;\\nhead:%s\\ntail:%s\\n&quot;,head,tail); printf(&quot;\\n深度：%d&quot;, GetGListDepth(L)); return 0; &#125; 结果 后面部分内容都遗失了，就到这里吧。","categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"数据结构","slug":"课程作业/数据结构","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://loststar.tech/tags/%E6%95%B0%E7%BB%84/"},{"name":"广义表","slug":"广义表","permalink":"https://loststar.tech/tags/%E5%B9%BF%E4%B9%89%E8%A1%A8/"},{"name":"鞍点","slug":"鞍点","permalink":"https://loststar.tech/tags/%E9%9E%8D%E7%82%B9/"},{"name":"稀疏矩阵转置","slug":"稀疏矩阵转置","permalink":"https://loststar.tech/tags/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/"}],"author":"loststar"},{"title":"PDO连接缓慢的一个解决方法","slug":"PDO连接缓慢的一个解决方法","date":"2021-01-04T14:25:58.000Z","updated":"2021-12-14T15:39:46.197Z","comments":true,"path":"posts/2e64231/","link":"","permalink":"https://loststar.tech/posts/2e64231/","excerpt":"","text":"太长不看版：把 localhost 换成 127.0.0.1 1 问题在写一个小玩具的时候，一个逻辑十分简单的接口耗时超过2s，十分不正常。 2 排查2.1 接口检查接口逻辑十分简单，只包含了两个部分：数据查询、json_encode。json_encode 作为内置函数，加上以往经验，不太可能是问题的关键。通过比较部分执行时间，数据查询部分执行时间约为另一部分的 10E5 倍。再用 navicat 手工构造执行了一下相同语句，耗时仅有 0.017s，更加肯定了连接上的问题。 2.2 查看user表既然是连接上的问题，那就去看看 mysql 库里有没有好康的。无意之中点到了 user 表，突然有了一些想法。 莫非，是 ipv6 的锅？ 随手 ping 了一下 localhost 试着用 telnet 连接了一下 3306 端口，localhost 和 127.0.0.1 成功，::1 失败。 3 解决于是乎，将 mysql:host=localhost 改为 mysql:host=127.0.0.1 ，刷新 好起来了 所以，估计是 localhost 默认解析为 ipv6 地址，导致无法连接和超时。体现在应用上就是加载时间长了。","categories":[{"name":"技术","slug":"技术","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/"},{"name":"php","slug":"技术/php","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/php/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://loststar.tech/tags/mysql/"},{"name":"问题排查","slug":"问题排查","permalink":"https://loststar.tech/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"name":"PDO","slug":"PDO","permalink":"https://loststar.tech/tags/PDO/"},{"name":"方法记录","slug":"方法记录","permalink":"https://loststar.tech/tags/%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"}],"author":"loststar"},{"title":"hexo只在特定页面开启mathjax","slug":"hexo只在特定页面开启mathjax","date":"2020-08-04T11:10:05.000Z","updated":"2021-12-14T15:39:23.829Z","comments":true,"path":"posts/a7d694aa/","link":"","permalink":"https://loststar.tech/posts/a7d694aa/","excerpt":"","text":"在 Hexo-NexT 主题中，可以选择是否在所有页面加载 mathjax。但是在切换为 indigo 主题后，只能选择全局加载。对 themes/indigo/layout/_partial/plugins/mathjax.ejs进行少许修改即可实现。 在第2行加入 &lt;% if (page.mathjax)&#123; %&gt; 在第24行加入&lt;% &#125; %&gt; 在需要使用mathjax的文章头部加入 mathjax: true 即可 修改后 mathjax.ejs 全部内容如下 &lt;% if (theme.mathjax)&#123; %> &lt;% if (page.mathjax)&#123; %> &lt;!-- mathjax config similar to math.stackexchange --> &lt;script type=\"text/x-mathjax-config\"> MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;); MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for(i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += ' has-jax'; &#125; &#125;); &lt;/script> &lt;script async src=\"//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML\" async>&lt;/script> &lt;% &#125; %> &lt;% &#125; %>","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"hexo","slug":"博客相关/hexo","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo/"}],"tags":[{"name":"方法记录","slug":"方法记录","permalink":"https://loststar.tech/tags/%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"},{"name":"mathjax","slug":"mathjax","permalink":"https://loststar.tech/tags/mathjax/"},{"name":"indigo","slug":"indigo","permalink":"https://loststar.tech/tags/indigo/"}],"author":"loststar"},{"title":"创新实践课作业--图像预处理作业","slug":"创新实践课作业-图像预处理作业","date":"2020-07-14T14:31:48.000Z","updated":"2021-11-20T15:07:16.892Z","comments":true,"path":"posts/fdb6251f/","link":"","permalink":"https://loststar.tech/posts/fdb6251f/","excerpt":"","text":"本文章由Jupyter Notebook导出 任务一请用在不使用Opencv框架的情况下实现图片的镜像操作，最终显示原图片，垂直镜像图片和水平镜像图片。 from PIL import Image,ImageFilter import numpy as np import matplotlib.pyplot as plt %matplotlib inline im = Image.open(\"./lena.png\") plt.figure(\"Text\") # 图像窗口名称 plt.imshow(im) 水平镜像 im2=im.transpose(Image.FLIP_LEFT_RIGHT) plt.imshow(im2) 垂直镜像 im3=im.transpose(Image.FLIP_TOP_BOTTOM) plt.imshow(im3) 任务二请在不使用Opencv框架的情况下实现Gamma变换，并显示原图像，Gamma值为0.5和2时的图像。 im_G=im.convert(\"L\") plt.imshow(im_G) gamma函数 def gamma_fun(gm): return lambda x:pow(x/255,gm)*255 gamma=0.5 im_gm05=im_G.point(gamma_fun(0.5)) plt.imshow(im_gm05) gamma=2 im_gm2=im_G.point(gamma_fun(2)) plt.imshow(im_gm2) 任务三请在不使用Opencv框架的情况下完成中值滤波操作，最终显示原图像，滤波窗口大小为3时的滤波效果和滤波窗口大小为5时的滤波效果。 原始图像 plt.imshow(im) 窗口为3 im_mid3=im.filter(ImageFilter.MedianFilter(3)) plt.imshow(im_mid3) 窗口为5 im_mid5=im.filter(ImageFilter.MedianFilter(5)) plt.imshow(im_mid5) 任务四请在不使用Opencv框架的情况下完成锐化操作，最终显示原图像，并使用1.2.19中的两个锐化算子进行锐化，然后显示图像效果，再使用PIL库内置锐化方法进行锐化操作，并显示结果。 原始图片 plt.imshow(im) 算子1 $$\\begin{bmatrix} -1 &amp; -1 &amp; -1 \\ -1 &amp; 9 &amp; -1 \\ -1 &amp; -1 &amp; -1 \\end{bmatrix}$$ im_s1=im.filter(ImageFilter.Kernel((3,3),(-1,-1,-1,-1,9,-1,-1,-1,-1))) plt.imshow(im_s1) 算子2$$\\begin{bmatrix} 0 &amp; -1 &amp; 0 \\ -1 &amp; 8 &amp; -1 \\ 0 &amp; 1 &amp; 0 \\end{bmatrix}/4$$ im_s2=im.filter(ImageFilter.Kernel((3,3),(0/4,-1/4,0/4,-1/4,8/4,-1/4,0/4,-1/4,0/4))) plt.imshow(im_s1) 内置方法 im_spil=im.filter(ImageFilter.SHARPEN) plt.imshow(im_spil) ipynb下载链接图像预处理作业.ipynb","categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"创新实践课","slug":"课程作业/创新实践课","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%AF%BE/"}],"tags":[{"name":"预处理","slug":"预处理","permalink":"https://loststar.tech/tags/%E9%A2%84%E5%A4%84%E7%90%86/"},{"name":"PIL","slug":"PIL","permalink":"https://loststar.tech/tags/PIL/"}],"author":"loststar"},{"title":"Jupyter Notebook修改默认路径","slug":"Jupyter-Notebook修改默认路径","date":"2020-07-14T01:45:18.000Z","updated":"2020-07-27T07:50:45.696Z","comments":true,"path":"posts/eccdc33c/","link":"","permalink":"https://loststar.tech/posts/eccdc33c/","excerpt":"","text":"Jupyter Notebook默认打开的路径是C:/Users/用户名，这非常不方便。修改的方法有两种。 方法1找到Jupyter Notebook的快捷方式，将路径中的%USERPROFILE%改成想要作为根目录的地址。 方法2本方法参考了ipython notebook 如何修改一开始打开的文件夹路径？- 知乎 打开C:/Users/你的账户/.jupyter/看看是否存在jupyter_notebook_config.py，如果有，跳到3 如果没有，在命令行输入 jupyter notebook --generate-config 打开C:/Users/你的账户/.jupyter/jupyter_notebook_config.py 找到#c.NotebookApp.notebook_dir = &#39;&#39; 删除井号，引号内改为需要的路径 删除快捷方式里面的%USERPROFILE%（非常重要，否则路径不会改变，当时在这里迷惑了很久）","categories":[{"name":"方法记录","slug":"方法记录","permalink":"https://loststar.tech/categories/%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"JupyterNotebook","slug":"JupyterNotebook","permalink":"https://loststar.tech/tags/JupyterNotebook/"}],"author":"loststar"},{"title":"操作系统实验2--银行家算法模拟实现","slug":"操作系统实验2-银行家算法模拟实现","date":"2020-07-10T14:34:11.000Z","updated":"2021-11-20T15:07:34.651Z","comments":true,"path":"posts/aa64c4bc/","link":"","permalink":"https://loststar.tech/posts/aa64c4bc/","excerpt":"","text":"问题描述利用 C 语言设计与实现银行家算法，构建计算机系统资源的模拟管理和处理场景并对自己的银行家算法实现方案加以测试验证。 实验要求 基于 C语言的银行家算法的设计与实现 计算机系统资源的模拟管理和处理场景的构建（初始化操作包括系统各类资源配备情况、一组并发进程及相应资源最大需求明细，进程申请资源操作需要指定进程及其对所需各类资源的申请数量，进程释放资源操作需要指定进程及其对当前所占用各类资源的释放数量） 算法原型应能正确处理进程申请/释放资源的各种操作请求 针对银行家算法原型开展基于计算机系统资源管理的完备的测试验证 项目结构宏定义、全局变量和结构体定义#define TRUE 1 #define FALSE 0 #define ERR -1 #define N 5 #define SUCCESS 0 typedef struct Resource &#123; int A; int B; int C; &#125;RES; typedef struct Request &#123; int id; RES res; &#125;REQ; RES Available,Work,Max[N],Allocation[N]&#x3D;&#123;&#123;0,0,0&#125;&#125;,Need[N]; REQ Request; int Finish[N]; N是进程数，TRUE FALSE ERR SUCCESS是标志位，Resource结构体存储资源，Request结构体存储请求，Available Work Max[N] Allocation[N] Need[N] Request Finish对应银行家算法里的各个部分。 函数一览void init(); void run(); int isAllFinish(int* finish); int cmpReqNeed(); int cmpReqAvailable(); int preAllocate(); int safeCheck(); int isASmallerB(RES A,RES B); RES add(RES A,RES B); RES minus(RES A,RES B); void printLog(); 详细设计初始化void init() &#123; printf(&quot;输入总资源数(A B C):\\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;Available.A,&amp;Available.B,&amp;Available.C); printf(&quot;依次输入%d个进程所需最大资源(A B C):\\n&quot;,N); for(int i&#x3D;0;i&lt;N;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;Max[i].A,&amp;Max[i].B,&amp;Max[i].C); Need[i]&#x3D;Max[i]; &#125; return; &#125; 获取用户输入的总资源数和每个进程所需最大资源数，并且开始时每个Allocation 资源都是0，所以Need 赋值为 Max。 结构体工具函数RES add(RES A,RES B) &#123; RES temp; temp.A&#x3D;A.A+B.A; temp.B&#x3D;A.B+B.B; temp.C&#x3D;A.C+B.C; return temp; &#125; RES minus(RES A,RES B) &#123; RES temp; temp.A&#x3D;A.A-B.A; temp.B&#x3D;A.B-B.B; temp.C&#x3D;A.C-B.C; return temp; &#125; int isASmallerB(RES A,RES B) &#123; if(A.A&lt;&#x3D;B.A&amp;&amp;A.B&lt;&#x3D;B.B&amp;&amp;A.C&lt;&#x3D;B.C) &#123; return TRUE; &#125; return FALSE; &#125; 因为C语言没有运算符重载，所以自定义加、减、小于等于函数方便阅读和编写 日志输出void printLog() &#123; printf(&quot;***Log Start***\\n&quot;); printf(&quot;系统剩余资源:\\n%d %d %d\\n&quot;,Available.A,Available.B,Available.C); printf(&quot;线程需求资源:\\n&quot;); for(int i&#x3D;0;i&lt;N;i++) &#123; printf(&quot;%d %d %d\\n&quot;,Need[i].A,Need[i].B,Need[i].C); &#125; printf(&quot;完成情况:\\n&quot;); for(int i&#x3D;0;i&lt;N;i++) &#123; printf(&quot;%d &quot;,Finish[i]); &#125; printf(&quot;\\n***Log End***\\n&quot;); &#125; 银行家算法主体void run() &#123; while (!isAllFinish(Finish)) &#123; printLog(); printf(&quot;---------------------------------------\\n输入资源申请(id A B C):\\n&quot;); scanf(&quot;%d%d%d%d&quot;,&amp;Request.id,&amp;Request.res.A,&amp;Request.res.B,&amp;Request.res.C); if(cmpReqNeed()!&#x3D;ERR&amp;&amp;cmpReqAvailable()!&#x3D;ERR) &#123; if(preAllocate()!&#x3D;ERR) &#123; if(Need[Request.id].A&#x3D;&#x3D;0&amp;&amp;Need[Request.id].B&#x3D;&#x3D;0&amp;&amp;Need[Request.id].C&#x3D;&#x3D;0) &#123; Available&#x3D;add(Available,Allocation[Request.id]); Finish[Request.id]&#x3D;TRUE; &#125; &#125; &#125; &#125; &#125; 通过isAllFinish 函数判断是否所有进程已经完成，接收用户输入以模拟进程对资源的请求，通过cmpReqNeed 和cmpReqAvailable 检测请求是否超出，如果不超出，使用 preAllocate 进行预分配，如果预分配安全且执行完成，释放资源。 预分配int preAllocate() &#123; RES tempAvailable&#x3D;Available,tempAllocation&#x3D;Allocation[Request.id],tempNeed&#x3D;Need[Request.id]; Available&#x3D;minus(Available,Request.res); Allocation[Request.id]&#x3D;add(Allocation[Request.id],Request.res); Need[Request.id]&#x3D;minus(Need[Request.id],Request.res); if(safeCheck()&#x3D;&#x3D;ERR) &#123; Available&#x3D;tempAvailable; Allocation[Request.id]&#x3D;tempAllocation; Need[Request.id]&#x3D;tempNeed; return ERR; &#125; return SUCCESS; &#125; 首先使用temp开头的几个变量将原始资源余量等信息暂存，然后试着去分配，调用safeCheck检测安全性，如果不安全，则撤销预分配。 安全性检测int safeCheck() &#123; int tempFinish[N]; int safeList[N],safeNum&#x3D;0; int flag; for(int i&#x3D;0;i&lt;N;i++) &#123; tempFinish[i]&#x3D;Finish[i]; &#125; Work&#x3D;Available; while (isAllFinish(tempFinish)!&#x3D;TRUE) &#123; flag&#x3D;FALSE; for(int i&#x3D;0;i&lt;N;i++) &#123; if(tempFinish[i]&#x3D;&#x3D;FALSE&amp;&amp;isASmallerB(Need[i],Work)) &#123; Work&#x3D;add(Work,Allocation[i]); tempFinish[i]&#x3D;TRUE; safeList[safeNum++]&#x3D;i; flag&#x3D;TRUE; &#125; &#125; &#125; if(flag&#x3D;&#x3D;FALSE) &#123; printf(&quot;不安全\\n&quot;); return ERR; &#125; else &#123; printf(&quot;安全序列:\\n&quot;); for(int i&#x3D;0;i&lt;safeNum;i++) &#123; printf(&quot;线程%d &quot;,safeList[i]); &#125; printf(&quot;\\n&quot;); return SUCCESS; &#125; &#125; 循环查找资源能否有满足的线程，直到找不到或所有线程执行完毕。如果是安全的，输出安全序列。 运行测试略","categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"操作系统","slug":"课程作业/操作系统","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://loststar.tech/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"银行家算法","slug":"银行家算法","permalink":"https://loststar.tech/tags/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"}],"author":"loststar"},{"title":"豆瓣apikey分享","slug":"豆瓣apikey分享","date":"2020-06-21T01:20:56.000Z","updated":"2021-12-14T15:37:48.195Z","comments":true,"path":"posts/339a8b4c/","link":"","permalink":"https://loststar.tech/posts/339a8b4c/","excerpt":"","text":"我的博客一直使用hexo-douban来生成读书页面，可是最近一段时间，页面变成了这样子。 在查阅/node_modules/hexo-douban/books-generator.js后，发现抓取的API为&#39;https://api.douban.com/v2/book/user/&#39; + user + &#39;/collections?start=&#39; + start + &#39;&amp;count=100&#39; 在浏览器中访问API，发现返回invalid_apikey 在网络搜索后发现了一个可以用的key: 0df993c66c0c636e29ecbb5344252a4a 也就是说，将第21行的API地址改为&#39;https://api.douban.com/v2/book/user/&#39; + user + &#39;/collections?apikey=0df993c66c0c636e29ecbb5344252a4a&amp;start=&#39; + start + &#39;&amp;count=100&#39;即可解决。 最后，推荐一下这个插件，挺好用的。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"hexo","slug":"博客相关/hexo","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo/"}],"tags":[{"name":"豆瓣","slug":"豆瓣","permalink":"https://loststar.tech/tags/%E8%B1%86%E7%93%A3/"},{"name":"apikey","slug":"apikey","permalink":"https://loststar.tech/tags/apikey/"}]},{"title":"操作系统实验1--Linux命令解析程序设计与实现","slug":"操作系统实验1-Linux命令解析程序设计与实现","date":"2020-03-21T12:21:00.000Z","updated":"2021-11-30T14:11:24.884Z","comments":true,"path":"posts/9de5b70b/","link":"","permalink":"https://loststar.tech/posts/9de5b70b/","excerpt":"","text":"问题描述​ 探索、理解并掌握操作系统命令释器的设计原和实现机制，基于 Linux内核进行相应命令解释程序的设计和实现，并在 Linux操作平台上加以实现。 实验要求Linux 命令解释程序功能设计要求：（1）选取和设计实现一组内部命令（五条以上）；（2）外部命令执行采用直接调用 exec 系统调用的方式来实现；（3）至少一条内部命令采用直接调用相应系统调用的方式来实现；（4）系统环境变量（至少包括当前目录）支持；（5）在 Linux 操作系统上启用（或替换原命令解释程序 Shell）并测试验证。 项目结构函数一览void print_welcome(); //打印欢迎信息 void split(char *src,const char *separator,char **dest,int *num); //分割输入的命令 void my_cd(char **arr); //内部命令cd的实现 void my_pwd(char **arr); //内部命令pwd的实现 void my_echo(); //内部命令echo的实现 void my_exit(); //内部命令exit的实现 HQueue init_history(HQueue q); //历史记录队列初始化 HQueue add_history(HQueue q,int num); //添加历史记录 void my_history(HQueue q); //内部命令history的实现 int check_env(char **arr); //环境变量的支持 void my_outer(char **arr); //外部命令的实现 数据结构和全局变量定义int IS_STOP=0; //是否退出myshell char cmd[256]; //输入的命令 char historycmd[256]; //输入的命令的备份，用作历史记录 char *arr[128]; //命令分割后存储 char *env[256]=&#123;\"/home\",\"/usr\"&#125;; //环境变量 int env_N=2; //环境变量数 typedef struct HistoryNode &#123; //历史记录队列节点 char cmd[256]; struct HistoryNode *next; &#125;HNode; typedef struct HistoryQueue &#123; //历史记录队列 HNode *head,*tail; int num; &#125;HQueue; 详细设计内部命令cd的设计​ cd命令的作用是切换工作目录，直接使用了系统调用，设计如下： void my_cd(char **arr) &#123; if (arr[1]&amp;&amp;!syscall(SYS_access,arr[1],0)) &#123; syscall(SYS_chdir,arr[1]); &#125; else &#123; printf(\"目录不存在！\\n\"); &#125; &#125; ​ 该函数使用了syscall 来调用系统调用SYS_access 来判断目录是否存在，以及使用了系统调用 SYS_chdir 来切换目录。 内部命令pwd的设计​ pwd命令的作用是显示工作目录，设计如下： void my_pwd(char **arr) &#123; char wd[4096]; puts(getcwd(wd, 4096)); &#125; ​ 该函数使用了 getcwd 函数来获取路径并且存入字符数组wd中，用puts输出 内部命令echo的设计​ echo命令的作用是输出命令里的字符，设计如下： void my_echo() &#123; char temp[256]; int i; for(i=5;i&lt;strlen(historycmd);i++) &#123; temp[i-5]=historycmd[i]; &#125; puts(temp); &#125; 内部命令history的设计​ history命令的作用是显示历史输入的命令，设计如下： //在程序开始之初调用，初始化链队列 HQueue init_history(HQueue q) &#123; q.head=(HNode*)malloc(sizeof(HNode)); if(q.head==NULL) &#123; printf(\"init_history申请内存错误\"); &#125; q.tail=q.head; q.num=0; return q; &#125; //该函数在每输入一条非空指令后调用，将新输入的指令存入链队列 HQueue add_history(HQueue q,int num) &#123; HNode *temp=(HNode*)malloc(sizeof(HNode)); if(temp==NULL) &#123; printf(\"add_history申请内存错误\"); &#125; q.tail->next=temp; q.tail=q.tail->next; q.num=q.num+1; strcpy(q.tail->cmd,historycmd); return q; &#125; //该函数按顺序输出序号和历史指令 void my_history(HQueue q) &#123; HNode *temp=q.head->next; if(temp==NULL) &#123; printf(\"链表错误！\\n\"); &#125; int i=0; for(i=0;i&lt;q.num;i++) &#123; printf(\"%d \",i+1); puts(temp->cmd); temp=temp->next; &#125; &#125; 内部命令exit的设计​ exit的作用是退出shell void my_exit() &#123; printf(&quot;即将退出myshell\\n&quot;); IS_STOP&#x3D;1; &#125; ​ 该函数将全局变量 IS_STOP 置为1，主循环独取后会停止 环境变量的支持int check_env(char** arr) &#123; int is_exist=0; char wd[256]; if(!(access(arr[0],0))) &#123; getcwd(wd, 256); strcat(wd,\"/\"); strcat(wd,arr[0]); is_exist=1; &#125; else &#123; int i; for(i=0;i&lt;env_N;i++) &#123; strcpy(wd,env[i]); strcat(wd,\"/\"); strcat(wd,arr[0]); if(!(access(wd,0))) &#123; is_exist=1; break; &#125; &#125; &#125; if(is_exist) &#123; printf(\"%s在环境变量内!\",arr[0]); printf(\"路径是：%s\\n执行结果：\\n\",wd); pid_t pid = fork(); if (pid == 0) &#123; execvp(wd, arr); return 255; &#125; wait(NULL); &#125; return is_exist; &#125; ​ 该函数使用access搜索在给定路径集合env里是否存在名为 arr[0] 的可执行程序，若存在则执行。 外部命令的实现void my_outer(char **arr) &#123; printf(\"%s是外部命令！\\n执行结果：\\n\",arr[0]); pid_t pid = fork(); if (pid == 0) &#123; execvp(arr[0], arr); &#125; wait(NULL); &#125; 该函数使用exec调用外部命令 主函数设计int main() &#123; print_welcome(); //输出欢迎信息 int num; //链队列初始化 HQueue history; history=init_history(history); while (!IS_STOP) &#123; //循环直到遇到exit printf(\"myshell> \"); //命令提示符 fflush(stdin); fgets(cmd, 256, stdin); //读入命令 int i=0; while (cmd[i]!='\\n') &#123; i++; &#125; cmd[i] = '\\0'; //将\\n替换为\\0 strcpy(historycmd,cmd); arr[0] = cmd; split(cmd,\" \",&amp;arr[0],&amp;num); //分割命令 arr[num]=NULL; //无输入 if (!arr[0])&#123; break; &#125; //内部命令 else if (strcmp(arr[0], \"cd\") == 0) &#123; //内部命令cd my_cd(arr); &#125; else if (strcmp(arr[0], \"pwd\") == 0) &#123; //内部命令pwd my_pwd(arr); &#125; else if (strcmp(arr[0], \"echo\") == 0) &#123; //内部命令echo my_echo(arr); &#125; else if (strcmp(arr[0], \"history\") == 0) &#123; //内部命令history my_history(history); &#125; else if (strcmp(arr[0], \"exit\") == 0) &#123; //内部命令exit my_exit(); &#125; //环境变量 else if (check_env(arr)) &#123;&#125; //外部命令 else &#123; my_outer(arr); &#125; history=add_history(history,i); //历史记录 &#125; &#125; 验证测试欢迎界面 内部命令cd 和 pwd 命令用pwd命令显示当前目录，cd切换后再用pwd显示切换后的目录 与预期相符 echo 命令输出hello 17281144 与预期相符 history 命令输出历史 与预期相符 exit命令退出shell 与预期相符 环境变量将如下代码编译成为名为 hello 的可执行文件，放在 /home 目录下，并且将目录加入 env 数组。 #include&lt;stdio.h> int main() &#123; printf(\"Hello World\\n\"); &#125; 直接输入hello 与预期相符 外部命令以ping 命令作为示例 与预期相符","categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"操作系统","slug":"课程作业/操作系统","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://loststar.tech/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"命令解析","slug":"命令解析","permalink":"https://loststar.tech/tags/%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/"},{"name":"shell","slug":"shell","permalink":"https://loststar.tech/tags/shell/"}]},{"title":"数据结构实验2--栈和队列","slug":"数据结构实验2-栈和队列","date":"2020-03-01T11:12:04.000Z","updated":"2021-11-23T01:37:31.197Z","comments":true,"path":"posts/959bb1f8/","link":"","permalink":"https://loststar.tech/posts/959bb1f8/","excerpt":"","text":"本系列文章广泛借鉴了各种教材和博客文章，由于完成时间比较久远，如果有遗漏标注的请联系我补充或删除解答。本文中解答仅供参考学习。 商场停车场题目​ 某商场有一个100个车位的停车场，当车位未满时，等待的车辆可以进入并计时；当车位已满时，必须有车辆离开，等待的车辆才能进入；当车辆离开时计算停留的的时间，并且按照每小时1元收费。 ​ 汽车的输入信息格式可以是（进入/离开，车牌号，进入/离开时间），要求可以随时显示停车场内的车辆信息以及收费历史记录。 解答#include&lt;stdio.h> #include&lt;time.h> #include&lt;stdlib.h> #include&lt;string.h> #define MAXSPACE 100 #define PRICEPERSECOND 1 typedef struct vehicle //车辆信息 &#123; char carNumber[8]; //车牌号码 time_t parkTime; //停车时间 &#125;Vehicle; typedef struct space //车位信息 &#123; Vehicle carInfo; //车位里停的车 int isParked; //车位状态 &#125;Space; typedef struct lot //停车场信息 &#123; Space* allSpace; //所有车位 int emptySpace; //剩余车位数 &#125; Lot; typedef struct history //收费记录 &#123; char carNumber[8]; time_t parkTime; time_t leaveTime; int price; struct history *next; &#125;History; void printLot(Lot parkingLot) &#123; printf(\"=================================================\\n现在时间：%lld\\n停车场剩余空位%d个\\n\", time(NULL), parkingLot.emptySpace); for (int i = 0; i &lt; MAXSPACE; i++) &#123; if (parkingLot.allSpace[i].isParked == 1) &#123; printf(\"---------------------\\n车牌：%s\\n停车时间：%lld\\n\", parkingLot.allSpace[i].carInfo.carNumber, parkingLot.allSpace[i].carInfo.parkTime); &#125; &#125; printf(\"---------------------\\n=================================================\\n\"); &#125; void printHistory(History *head) &#123; History *temp = head; int i = 1; if (temp->price != 0) &#123; printf(\"第%d笔，车牌号：%s，收费：%d元\\n\", 1, temp->carNumber, temp->price); while (temp->next!=NULL) &#123; temp = temp->next; i++; printf(\"第%d笔，车牌号：%s，收费：%d元\\n\", i, temp->carNumber, temp->price); &#125; &#125; &#125; Lot parkVehicle(Lot parkingLot) &#123; if (parkingLot.emptySpace == 0) &#123; printf(\"车位满，请离开\"); return parkingLot; &#125; for (int i = 0; i &lt; MAXSPACE; i++) &#123; if (parkingLot.allSpace[i].isParked == 0) //找到空车位 &#123; printf(\"请输入7位车牌号（例：JA10086）：\\n\"); scanf(\"%s\", parkingLot.allSpace[i].carInfo.carNumber); parkingLot.allSpace[i].carInfo.parkTime= time(NULL); parkingLot.allSpace[i].isParked = 1; parkingLot.emptySpace--; printf(\"现在时间%lld,%s停车成功\\n\", parkingLot.allSpace[i].carInfo.parkTime,parkingLot.allSpace[i].carInfo.carNumber); return parkingLot; &#125; &#125; &#125; Lot leaveVehicle(Lot parkingLot, History* head) &#123; if (parkingLot.emptySpace == MAXSPACE) &#123; printf(\"停车场空\\n\"); return parkingLot; &#125; char carNumber[8]; time_t nowTime; int parkingFee; printf(\"请输入7位车牌号（例：JA10086）：\\n\"); scanf(\"%s\", carNumber); for (int i = 0; i &lt; MAXSPACE; i++) &#123; if (strcmp(parkingLot.allSpace[i].carInfo.carNumber,carNumber)==0) &#123; parkingLot.allSpace[i].isParked = 0; parkingLot.emptySpace++; nowTime = time(NULL); parkingFee = PRICEPERSECOND * (nowTime - parkingLot.allSpace[i].carInfo.parkTime); printf(\"%s离开成功，收费%d元\\n\", parkingLot.allSpace[i].carInfo.carNumber, parkingFee); //储存收费记录 if (head->price == 0) &#123; strcpy(head->carNumber, parkingLot.allSpace[i].carInfo.carNumber); head->parkTime = parkingLot.allSpace[i].carInfo.parkTime; head->leaveTime = nowTime; head->price = parkingFee; &#125; else &#123; History *temp = head; while (temp->next!=NULL) &#123; temp = temp->next; &#125; temp->next = (History*)malloc(sizeof(History)); temp = temp->next; strcpy(temp->carNumber, parkingLot.allSpace[i].carInfo.carNumber); temp->parkTime = parkingLot.allSpace[i].carInfo.parkTime; temp->leaveTime = nowTime; temp->price = parkingFee; temp->next = NULL; &#125; return parkingLot; &#125; &#125; &#125; void startSystem(Lot parkingLot, History* head) &#123; while (true) &#123; int i; printf(\"1.停车\\n2.离开\\n3.打印停车场状态\\n4.打印收费历史\\n\"); scanf(\"%d\", &amp;i); switch (i) &#123; case 1: parkingLot = parkVehicle(parkingLot); break; case 2: parkingLot = leaveVehicle(parkingLot, head); break; case 3: printLot(parkingLot); break; case 4: printHistory(head); break; default: break; &#125; &#125; &#125; int main() &#123; Lot parkingLot; parkingLot.allSpace = (Space*)malloc(MAXSPACE * sizeof(Space)); parkingLot.emptySpace = MAXSPACE; for (int i = 0; i &lt; MAXSPACE; i++) &#123; parkingLot.allSpace[i].isParked = 0; &#125; History* head = (History*)malloc(sizeof(History)); head->price = 0; head->next = NULL; startSystem(parkingLot, head); &#125; 运行结果 银行营业厅题目​ 某银行营业厅共有6个营业窗口，设有排队系统广播叫号，该银行的业务分为公积金、银行卡、理财卡等三种。公积金业务指定1号窗口，银行卡业务指定2、3、4号窗口，理财卡业务指定5、6号窗口。但如果5、6号窗口全忙，而2、3、4号窗口有空闲时，理财卡业务也可以在空闲的2、3、4号窗口之一办理。 ​ 客户领号、业务完成可以作为输入信息，要求可以随时显示6个营业窗口的状态。 解答#include&lt;stdio.h> #include&lt;stdlib.h> int windows[7] = &#123; 0 &#125;; int number = 0; //顾客领取的号码 typedef struct QNode &#123; int data; struct QNode *next; &#125;QNode; typedef struct LinkQueue &#123; QNode *front; QNode *rear; &#125;LinkQueue; int initQueue(LinkQueue &amp;Q) &#123; Q.front = Q.rear = (QNode*)malloc(sizeof(QNode)); if (!Q.front) &#123; return -1; &#125; Q.front->next = NULL; return 0; &#125; int enQueue(LinkQueue &amp;Q, int data) &#123; QNode *p = (QNode*)malloc(sizeof(QNode)); if (!p) &#123; return -1; &#125; p->data = data; p->next = NULL; Q.rear->next = p; Q.rear = p; return 0; &#125; int deQueue(LinkQueue &amp;Q,int &amp;data) &#123; if (Q.front == Q.rear) &#123; return -1; &#125; QNode *p = Q.front->next; data = p->data; Q.front->next = p->next; if (p == Q.rear) &#123; Q.rear = Q.front; free(p); &#125; return 0; &#125; int isEmpty(LinkQueue &amp;Q) &#123; if (Q.front == Q.rear) &#123; return 1; &#125; return 0; &#125; void print(LinkQueue *Q) //输出队列中的元素 &#123; QNode *p; p = Q->front->next; //p结点指向链队列中存放第一个元素的结点 while (p) //沿链队列从队头到队尾的方向依次输出元素的值 &#123; printf(\"%d \", p->data); p = p->next; &#125; &#125; void entryBank(LinkQueue &amp;gjj, LinkQueue &amp;yhk, LinkQueue &amp;lck, LinkQueue &amp;customer1, LinkQueue &amp;customer2, LinkQueue &amp;customer3) &#123; int i,data; printf(\"请输入要办理的业务：\\n1.公积金\\n2.银行卡\\n3.理财卡\\n\"); scanf(\"%d\", &amp;i); number++; switch (i) &#123; case 1: if (!isEmpty(gjj)) &#123; deQueue(gjj,data); windows[data] = 1; printf(\"%d号顾客到%d号柜台办理\\n\", number, data); &#125; else &#123; enQueue(customer1,number); printf(\"%d号顾客到队列1等待\\n\", number); &#125; break; case 2: if (!isEmpty(yhk)) &#123; deQueue(yhk, data); windows[data] = 1; printf(\"%d号顾客到%d号柜台办理\\n\", number, data); &#125; else &#123; enQueue(customer2, number); printf(\"%d号顾客到队列2等待\\n\", number); &#125; break; case 3: if (!isEmpty(lck)) &#123; deQueue(lck, data); windows[data] = 1; printf(\"%d号顾客到%d号柜台办理\\n\", number, data); &#125; else if(!isEmpty(yhk)) &#123; deQueue(yhk, data); windows[data] = 1; printf(\"%d号顾客到%d号柜台办理\\n\", number, data); &#125; else &#123; enQueue(customer3, number); printf(\"%d号顾客到队列3等待\\n\", number); &#125; default: break; &#125; &#125; void leaveBank(LinkQueue &amp;gjj, LinkQueue &amp;yhk, LinkQueue &amp;lck, LinkQueue &amp;customer1, LinkQueue &amp;customer2, LinkQueue &amp;customer3) &#123; int i,number; printf(\"请输入办理完成的窗口（1-6）\\n\"); scanf(\"%d\", &amp;i); switch (i) &#123; case 1: if (!isEmpty(customer1)) &#123; deQueue(customer1, number); printf(\"%d号顾客到%d号柜台办理\\n\", number, i); &#125; else &#123; enQueue(gjj, i); windows[i] = 0; &#125; break; case 2: case 3: case 4: if (!isEmpty(customer2)) &#123; deQueue(customer2, number); printf(\"%d号顾客到%d号柜台办理\\n\", number, i); &#125; else if (!isEmpty(customer3)) &#123; deQueue(customer3, number); printf(\"%d号顾客到%d号柜台办理\\n\", number, i); &#125; else &#123; enQueue(yhk, i); windows[i] = 0; &#125; break; case 5: case 6: if (!isEmpty(customer3)) &#123; deQueue(customer3, number); printf(\"%d号顾客到%d号柜台办理\\n\", number, i); &#125; else &#123; enQueue(lck, i); windows[i] = 0; &#125; break; default: break; &#125; &#125; void startSystem(LinkQueue &amp;gjj, LinkQueue &amp;yhk, LinkQueue &amp;lck, LinkQueue &amp;customer1, LinkQueue &amp;customer2, LinkQueue &amp;customer3) &#123; int i; printf(\"请输入顾客行为：\\n1.进入\\n2.离开\\n3.查看窗口状态\\n\"); scanf(\"%d\", &amp;i); switch (i) &#123; case 1: entryBank(gjj, yhk, lck, customer1, customer2, customer3); break; case 2: leaveBank(gjj, yhk, lck, customer1, customer2, customer3); break; case 3: for (int j = 1; j &lt; 7; j++) &#123; windows[j] ? printf(\"%d号窗口有人\\n\", j) : printf(\"%d号窗口无人\\n\", j); &#125; break; default: break; &#125; &#125; int main() &#123; LinkQueue gjj, yhk, lck; //窗口队列 LinkQueue customer1, customer2, customer3; //顾客队列 //窗口队列初始化 initQueue(gjj); enQueue(gjj, 1); initQueue(yhk); enQueue(yhk, 2); enQueue(yhk, 3); enQueue(yhk, 4); initQueue(lck); enQueue(lck, 5); enQueue(lck, 6); //窗口队列初始化完毕 //顾客队列初始化 initQueue(customer1); initQueue(customer2); initQueue(customer3); //顾客队列初始化完毕 while (true) &#123; startSystem(gjj, yhk, lck, customer1, customer2, customer3); &#125; &#125; 运行结果 4阶斐波那契序列题目​ 4阶斐波那契序列如下：f0=f1=f2=0, f3=1,…,fi=fi-1+fi-2+fi-3+fi-4， ​ 利用容量为k=4的循环队列，构造序列的前n+1项（f0, f1 , f2 ,… fn ），要求满足fn ≤200而fn+1 &gt;200。 解答#include&lt;stdio.h> #define kk 4 #define max 200 struct queue &#123; int elem[kk]; int rear; &#125;cq; int f[100], n; void fb(int k) &#123; int i, j; for (i = 0; i &lt;= k - 2; i++) &#123; f[i] = 0; cq.elem[i] = 0; &#125; cq.elem[k - 1] = f[k - 1] = 1; //为第k个元素赋值，并放入队列cq cq.rear = k - 1; n = k; while (cq.elem[cq.rear] &lt; max) //利用循环队列依次求f[n] &#123; f[n] = 0; for (j = 0; j &lt; k; j++) &#123; f[n] = f[n] + cq.elem[j]; &#125; cq.rear = (cq.rear + 1) % k; cq.elem[cq.rear] = f[n]; n++; &#125; //利用循环队列依次求f[n] if (cq.elem[cq.rear] > max) n = n - 2; else n = n - 1; &#125; int main() &#123; int i; fb(kk); for (i = 0; i &lt;= n; i++) printf(\" %d \", f[i]); return 0; &#125; 运行结果 八皇后问题题目八皇后问题：设8皇后问题的解为 (x1, x2, x3, …,x8), 约束条件为：在8x8的棋盘上，其中任意两个xi 和xj不能位于棋盘的同行、同列及同对角线。要求用一位数组进行存储，输出所有可能的排列。 解答#include&lt;stdio.h&gt; #include&lt;math.h&gt; #define N 8 int count &#x3D; 0, position[N]; int isLegal(int i, int j) &#x2F;&#x2F;检查(i,j)上能否放棋子 &#123; int j1 &#x3D; j,i1 &#x3D; i,ok1 &#x3D; 1; &#x2F;&#x2F;检查第i行上能否放棋子 while ((j1 &gt; 1) &amp;&amp; ok1) &#123; j1--; ok1 &#x3D; position[j1] !&#x3D; i; &#125; j1 &#x3D; j; i1 &#x3D; i; &#x2F;&#x2F;检查对角线上能否放棋子 while ((j1 &gt; 1) &amp;&amp; (i1 &gt; 1) &amp;&amp; ok1) &#123; j1--; i1--; ok1 &#x3D; position[j1] !&#x3D; i1; &#125; j1 &#x3D; j; i1 &#x3D; i; &#x2F;&#x2F;检查另一对角线上能否放棋子 while ((j1 &gt; 1) &amp;&amp; (i1 &lt; N) &amp;&amp; ok1) &#123; j1--; i1++; ok1 &#x3D; position[j1] !&#x3D; i1; &#125; return ok1; &#125; int queen(int j) &#x2F;&#x2F;从第j列开始逐个试探 &#123; if (j &gt; N) &#123; count++; printf(&quot;count&#x3D;%d &quot;, count); for (int i &#x3D; 1; i &lt;&#x3D; N; i++) printf(&quot; %d&quot;, position[i]); printf(&quot;\\n&quot;); &#125; else for (int i &#x3D; 1; i &lt;&#x3D; N; i++) if (isLegal(i,j)) &#x2F;&#x2F;检查(i,j)上能否放棋子 &#123; position[j] &#x3D; i; &#x2F;&#x2F;在(i,j)上放一个棋子 queen(j + 1); &#125; return 0; &#125; int main() &#123; queen(1); &#125; 运行结果一共92种，比较多，就不截图了 count&#x3D;1 1 5 8 6 3 7 2 4 count&#x3D;2 1 6 8 3 7 4 2 5 count&#x3D;3 1 7 4 6 8 2 5 3 count&#x3D;4 1 7 5 8 2 4 6 3 count&#x3D;5 2 4 6 8 3 1 7 5 count&#x3D;6 2 5 7 1 3 8 6 4 count&#x3D;7 2 5 7 4 1 8 6 3 count&#x3D;8 2 6 1 7 4 8 3 5 count&#x3D;9 2 6 8 3 1 4 7 5 count&#x3D;10 2 7 3 6 8 5 1 4 count&#x3D;11 2 7 5 8 1 4 6 3 count&#x3D;12 2 8 6 1 3 5 7 4 count&#x3D;13 3 1 7 5 8 2 4 6 count&#x3D;14 3 5 2 8 1 7 4 6 count&#x3D;15 3 5 2 8 6 4 7 1 count&#x3D;16 3 5 7 1 4 2 8 6 count&#x3D;17 3 5 8 4 1 7 2 6 count&#x3D;18 3 6 2 5 8 1 7 4 count&#x3D;19 3 6 2 7 1 4 8 5 count&#x3D;20 3 6 2 7 5 1 8 4 count&#x3D;21 3 6 4 1 8 5 7 2 count&#x3D;22 3 6 4 2 8 5 7 1 count&#x3D;23 3 6 8 1 4 7 5 2 count&#x3D;24 3 6 8 1 5 7 2 4 count&#x3D;25 3 6 8 2 4 1 7 5 count&#x3D;26 3 7 2 8 5 1 4 6 count&#x3D;27 3 7 2 8 6 4 1 5 count&#x3D;28 3 8 4 7 1 6 2 5 count&#x3D;29 4 1 5 8 2 7 3 6 count&#x3D;30 4 1 5 8 6 3 7 2 count&#x3D;31 4 2 5 8 6 1 3 7 count&#x3D;32 4 2 7 3 6 8 1 5 count&#x3D;33 4 2 7 3 6 8 5 1 count&#x3D;34 4 2 7 5 1 8 6 3 count&#x3D;35 4 2 8 5 7 1 3 6 count&#x3D;36 4 2 8 6 1 3 5 7 count&#x3D;37 4 6 1 5 2 8 3 7 count&#x3D;38 4 6 8 2 7 1 3 5 count&#x3D;39 4 6 8 3 1 7 5 2 count&#x3D;40 4 7 1 8 5 2 6 3 count&#x3D;41 4 7 3 8 2 5 1 6 count&#x3D;42 4 7 5 2 6 1 3 8 count&#x3D;43 4 7 5 3 1 6 8 2 count&#x3D;44 4 8 1 3 6 2 7 5 count&#x3D;45 4 8 1 5 7 2 6 3 count&#x3D;46 4 8 5 3 1 7 2 6 count&#x3D;47 5 1 4 6 8 2 7 3 count&#x3D;48 5 1 8 4 2 7 3 6 count&#x3D;49 5 1 8 6 3 7 2 4 count&#x3D;50 5 2 4 6 8 3 1 7 count&#x3D;51 5 2 4 7 3 8 6 1 count&#x3D;52 5 2 6 1 7 4 8 3 count&#x3D;53 5 2 8 1 4 7 3 6 count&#x3D;54 5 3 1 6 8 2 4 7 count&#x3D;55 5 3 1 7 2 8 6 4 count&#x3D;56 5 3 8 4 7 1 6 2 count&#x3D;57 5 7 1 3 8 6 4 2 count&#x3D;58 5 7 1 4 2 8 6 3 count&#x3D;59 5 7 2 4 8 1 3 6 count&#x3D;60 5 7 2 6 3 1 4 8 count&#x3D;61 5 7 2 6 3 1 8 4 count&#x3D;62 5 7 4 1 3 8 6 2 count&#x3D;63 5 8 4 1 3 6 2 7 count&#x3D;64 5 8 4 1 7 2 6 3 count&#x3D;65 6 1 5 2 8 3 7 4 count&#x3D;66 6 2 7 1 3 5 8 4 count&#x3D;67 6 2 7 1 4 8 5 3 count&#x3D;68 6 3 1 7 5 8 2 4 count&#x3D;69 6 3 1 8 4 2 7 5 count&#x3D;70 6 3 1 8 5 2 4 7 count&#x3D;71 6 3 5 7 1 4 2 8 count&#x3D;72 6 3 5 8 1 4 2 7 count&#x3D;73 6 3 7 2 4 8 1 5 count&#x3D;74 6 3 7 2 8 5 1 4 count&#x3D;75 6 3 7 4 1 8 2 5 count&#x3D;76 6 4 1 5 8 2 7 3 count&#x3D;77 6 4 2 8 5 7 1 3 count&#x3D;78 6 4 7 1 3 5 2 8 count&#x3D;79 6 4 7 1 8 2 5 3 count&#x3D;80 6 8 2 4 1 7 5 3 count&#x3D;81 7 1 3 8 6 4 2 5 count&#x3D;82 7 2 4 1 8 5 3 6 count&#x3D;83 7 2 6 3 1 4 8 5 count&#x3D;84 7 3 1 6 8 5 2 4 count&#x3D;85 7 3 8 2 5 1 6 4 count&#x3D;86 7 4 2 5 8 1 3 6 count&#x3D;87 7 4 2 8 6 1 3 5 count&#x3D;88 7 5 3 1 6 8 2 4 count&#x3D;89 8 2 4 1 7 5 3 6 count&#x3D;90 8 2 5 3 1 7 4 6 count&#x3D;91 8 3 1 6 2 5 7 4 count&#x3D;92 8 4 1 3 6 2 7 5","categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"数据结构","slug":"课程作业/数据结构","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://loststar.tech/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"栈","slug":"栈","permalink":"https://loststar.tech/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://loststar.tech/tags/%E9%98%9F%E5%88%97/"},{"name":"停车场","slug":"停车场","permalink":"https://loststar.tech/tags/%E5%81%9C%E8%BD%A6%E5%9C%BA/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"https://loststar.tech/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"name":"N皇后问题","slug":"N皇后问题","permalink":"https://loststar.tech/tags/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"}]},{"title":"数据结构实验1--线性表","slug":"数据结构实验1-线性表","date":"2020-03-01T08:46:07.000Z","updated":"2021-11-23T01:36:56.351Z","comments":true,"path":"posts/e6fc5c45/","link":"","permalink":"https://loststar.tech/posts/e6fc5c45/","excerpt":"","text":"本系列文章广泛借鉴了各种教材和博客文章，由于完成时间比较久远，如果有遗漏标注的请联系我补充或删除解答。本文中解答仅供参考学习。 前言数据结构是我大二（2018-2019学年第二学期）的一门课，本文和后续文章将把课程里的约30道实验题补全到博客。 员工储存题目​ 某软件公司大约有30名员工，每名员工有姓名、工号、职务等属性，每年都有员工离职和入职。 ​ 把所有员工按照顺序存储结构建立一个线性表，建立离职和入职函数，当有员工离职或入职时，修改线性表，并且打印最新的员工名单。 解答#include&lt;stdio.h> #include&lt;stdlib.h> #include&lt;string.h> #define MEMBER_NUMBER 30 int maxid = 0; typedef struct member &#123; char name[10]; int id; char job[10]; &#125;Member; typedef struct company &#123; Member* member; int length; int last; &#125;Company; void printMembers(Company* company) &#123; for (int i = 0; i &lt; company->last; i++) &#123; printf(\"%s,%d,%s\\n\", company->member[i].name, company->member[i].id, company->member[i].job); &#125; printf(\"*************************************\\n\"); &#125; void initCompany(Company* company) &#123; company->member = (Member*)malloc(MEMBER_NUMBER * sizeof(Member)); company->length = MEMBER_NUMBER; company->last = 0; &#125; int joinCompany(Company* company, char* name, char* job) &#123; if (company->last >= company->length) &#123; printf(\"full\"); return -1; &#125; else &#123; strcpy(company->member[company->last].name, name); company->member[company->last].id = maxid + 1; strcpy(company->member[company->last].job, job); company->last += 1; maxid += 1; printMembers(company); return 0; &#125; &#125; int leaveCompany(Company* company, int id) &#123; if (company->last == 0) &#123; printf(\"empty\"); return -1; &#125; else &#123; for (int i = 0; i &lt; company->last; i++) &#123; if (company->member[i].id == id) &#123; for (int j = i + 1; j &lt; company->last; j++) &#123; company->member[j - 1] = company->member[j]; &#125; company->last -= 1; printMembers(company); return 0; &#125; &#125; printf(\"not found\"); return -1; &#125; &#125; int main() &#123; Company company; char joinname[10], joinjob[10]; int leaveid; int choose; initCompany(&amp;company); while (1) &#123; printf(\"请选择：\\n1.入职\\n2.离职\\n3.退出程序\\n\"); scanf(\"%d\", &amp;choose); switch (choose) &#123; case 1: printf(\"输入姓名：\\n\"); scanf(\"%s\", &amp;joinname); printf(\"输入职位：\\n\"); scanf(\"%s\", &amp;joinjob); joinCompany(&amp;company, joinname, joinjob); break; case 2: printf(\"输入离职id：\\n\"); scanf(\"%d\", &amp;leaveid); leaveCompany(&amp;company, leaveid); break; case 3: return 0; default: break; &#125; &#125; &#125; 运行结果 约瑟夫环题目​ 约瑟夫（Josephus）环问题：编号为1,2,3,…,n的n个人按顺时针方向围坐一圈，每人持有一个密码（正整数）。一开始任选一个正整数作为报数的上限值m，从第一个人开始按顺时针方向自1开始顺序报数,报到m时停止。报m的人出列，将他的密码作为新的m值，从他在顺时针方向上的下一人开始重新从1报数，如此下去，直到所有人全部出列为止。 ​ 建立n个人的单循环链表存储结构，运行结束后，输出依次出队的人的序号。 解答#include&lt;stdio.h> #include&lt;time.h> #include&lt;stdlib.h> #define N 30 typedef struct node &#123; int num; int pass; struct node* next; &#125;Node; int randNumber(int max) &#123; srand((unsigned)time(NULL)); return rand() % max + 1; &#125; int m = randNumber(N * 3); Node* initList() &#123; srand((int)time(0)); Node* head = (Node*)malloc(sizeof(Node)); head->num = 1; head->pass = randNumber(N * 3); Node* temp = head; for (int i = 1; i &lt; N; i++) &#123; Node* p = (Node*)malloc(sizeof(Node)); p->num = i + 1; p->pass = randNumber(N * 3); temp->next = p; temp = temp->next; &#125; temp->next = head; //末尾指向头部，构成单循环链表 return head; &#125; void playGame(Node* head) &#123; Node* temp1 = head, * temp2; while (head != head->next) &#123; if (m == 1) //删除头结点 &#123; while (temp1->next != head) &#123; temp1 = temp1->next; &#125; temp2 = head; temp1->next = head->next; head = head->next; m = temp2->pass; printf(\"delete id:%d\\n\", temp2->num); free(temp2); //printList(head); &#125; else &#123; for (int i = 1; i &lt; m - 1; i++) &#123; temp1 = temp1->next; &#125; temp2 = temp1->next; temp1->next = temp2->next; m = temp2->pass; head = temp1->next; printf(\"delete id:%d\\n\", temp2->num); free(temp2); //printList(head); &#125; &#125; &#125; int main() &#123; printf(\"Number m=%d\\n\", m); Node* head = initList(); //printList(head); playGame(head); &#125; 运行结果","categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"数据结构","slug":"课程作业/数据结构","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://loststar.tech/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"线性表","slug":"线性表","permalink":"https://loststar.tech/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"https://loststar.tech/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"}]},{"title":"生成 Outline 客户端的 accesskey","slug":"生成-Outline-客户端的-accesskey","date":"2019-03-16T11:53:14.000Z","updated":"2021-12-14T15:38:08.205Z","comments":true,"path":"posts/18ecdccb/","link":"","permalink":"https://loststar.tech/posts/18ecdccb/","excerpt":"","text":"Outline作为一款底层是ss的第三方梯子客户端，但是却不支持直接输入服务器信息，而是要输入ss://access-key。 在翻阅了ss的文档后，找到了SIP002 URI方案： SS-URI &#x3D;&quot;ss:&#x2F;&#x2F;&quot;userinfo&quot;@&quot;hostname&quot;:&quot;port[ &quot;&#x2F;&quot; ][ &quot;?&quot; plugin ][ &quot;#&quot; tag ]userinfo&#x3D;websafe-base64-encode-utf8(method &quot;:&quot;password) 也就是SS：//base64加密(方法：密码)@主机名：端口","categories":[{"name":"方法记录","slug":"方法记录","permalink":"https://loststar.tech/categories/%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"OUTLINE","slug":"OUTLINE","permalink":"https://loststar.tech/tags/OUTLINE/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://loststar.tech/tags/shadowsocks/"}]},{"title":"推荐一个展示示repo的hexo插件","slug":"推荐一个展示示repo的hexo插件","date":"2018-01-07T08:13:09.000Z","updated":"2021-12-14T15:40:40.617Z","comments":true,"path":"posts/7a64e458/","link":"","permalink":"https://loststar.tech/posts/7a64e458/","excerpt":"","text":"在博客展示github repo几乎是一个刚需。在使用Typecho的时候我就曾做了个小插件来自娱自乐。 现在换到hexo平台，发现早有前人造好了轮子。 使用方法&#123;% githubCard user:your_user [repo:your_repo] [width:400] [height:200] [theme:default] [client_id:your_client_id] [client_secret:your_client_secret] [align:text-align_position] %&#125; Argument Description user GitHub user name repo (Optional) GitHub repository name of the user. If omit then display only the user profile height (Optional) Widget’s height (in ‘px’). Default is 200. width (Optional) Widget’s width (in ‘px’). Default is 400. client_id (Optional) Your GitHub app client_id client_secret (Optional) Your GitHub app client_secret align (Optional) What kind of text-align is you want. Default is center. 替换CDN修改/node_modules/hexo-github-card/index.html，将第13行改为： &lt;script src=\"//cdn.jsdelivr.net/github-cards/latest/widget.js\">&lt;/script> 效果展示","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://loststar.tech/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://loststar.tech/tags/%E6%8F%92%E4%BB%B6/"},{"name":"github","slug":"github","permalink":"https://loststar.tech/tags/github/"},{"name":"repo","slug":"repo","permalink":"https://loststar.tech/tags/repo/"}]},{"title":"从wordpress到typecho再到hexo","slug":"从wordpress到typecho再到hexo","date":"2017-09-20T11:10:00.000Z","updated":"2021-12-14T15:36:07.487Z","comments":true,"path":"posts/c5f3d396/","link":"","permalink":"https://loststar.tech/posts/c5f3d396/","excerpt":"","text":"序：2017已不足百天，也差不多是入博坑5年时间了。5年里，换了3个大平台（略 unbelievable）。回顾这 一生 5年，也有些感想。 初入博坑：WordPress当年，觉得blog是个酷炫的玩意，于是跟风，按照随便百度来的教程，弄了一个。然而，由于缺乏动力以及没什么好记录，从建立到倒闭，只有一篇文——如何建立blog。 后来，进入新的学校，认识了 烟花，在烟花学长的指导下，入了vps，正正经经写文。再加上那时候在研究一些黑科技，出现了第一次产文高峰，也认识了很多志同道合的小伙伴。但是当时并没有关于网站的知识，php水平不知低到哪里去，对wordpress的实现原理也不甚了解，所以仅仅相当于娱乐，改改外观而已。 随着对php能力的进一步提升，开始模仿着写一些小插件，尝试同样功能的不同实现。不过，遇到了一个问题吧。当时使用的是搬瓦工的佛罗里达机房（貌似是的），访问速度堪忧，调试不方便。解决途径大概两 条。其一，学习前端知识，自行优化wp。其二，换一个更轻量级的平台。（不要问我为什么不在本地调试，因为不能装逼展示给人看）于是，我入了typecho的坑。 小试牛刀：Typecho一方面为了快，另一方面可以支持国产，typecho进入了视线。typecho的配置和wordpress一样简单。typecho示例页面打开时，这种简洁、清爽让我瞬间喜欢上这个平台。 在尝试typecho的时候，也是时间和点子较多的时候。文章第二次高产到来。除了写写小插件，小主题外，也尝试了二次开发（虽然没wp二次开发方便但也很舒服）。曾经有一次我甚至想为typecho修bug，只不过我自己的测试一直没过，时间原因，只好作罢。 typecho在我心里地位极高，除了没有主题商城外，其他都挺满意。或许是这样子码字太舒服，水文越来越多，有意思的内容越来越少。再加上忽然发现所用的主题最开始来自hexo平台，于是趁此机会，试试hexo。 由恨生爱：hexo相比于wp和ty的安装方式，hexo堪称反人类。手撸markdown和命令行形式提交一开始也挺不适应。 要不是每月可以省一笔vps的钱，当时应该会放弃了吧。后来想起来，幸好当时没放弃。 自从用了hexo，不用当心文章什么时候丢失了找不回来了，也可以把静态html直接部署到某个主机上，同步很舒服。当然，省钱不能不提。gayhub真是好东西。 Anyway，这也是一种新的开始。平台不重要，希望内容质量能提升上来，不忘写博初心就好。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"hexo","slug":"博客相关/hexo","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://loststar.tech/tags/wordpress/"},{"name":"hexo","slug":"hexo","permalink":"https://loststar.tech/tags/hexo/"},{"name":"typecho","slug":"typecho","permalink":"https://loststar.tech/tags/typecho/"}]},{"title":"关于json_decode转换json对象为数组的一个坑","slug":"关于json-decode转换json对象为数组的一个坑","date":"2017-08-05T14:11:57.000Z","updated":"2021-12-14T15:38:43.609Z","comments":true,"path":"posts/d646a445/","link":"","permalink":"https://loststar.tech/posts/d646a445/","excerpt":"","text":"今天在写一个小玩意的时候，使用了json_decode来处理一段返回结果。当我直接调用转换后数组下标的时候，提示如下错误。 PHP Fatal error: Cannot use object of type stdClass as array in *:\\*.php on line * 于是乎，前往php.net关于json_decode的页面查看文档。发现json_decode完整用法如下。 mixed json_decode ( string $json [, bool $assoc = false [, int $depth = 512 [, int $options = 0 ]]] ) 上面问题的原因就在于第二个参数assoc，文档内的解析是——当该参数为 TRUE 时，将返回 array 而非 object。 真相大白，刚刚我们操作并没有加上这个参数，而这个参数默认为false。所以操作的是一个对象而不是一个数组，自然会出错。 以php.net的示例代码结束本文。 例子： &lt;?php $json &#x3D; &#39;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;&#39;; var_dump(json_decode($json)); var_dump(json_decode($json, true)); ?&gt; 输出： object(stdClass)#1 (5) &#123; [&quot;a&quot;] &#x3D;&gt; int(1) [&quot;b&quot;] &#x3D;&gt; int(2) [&quot;c&quot;] &#x3D;&gt; int(3) [&quot;d&quot;] &#x3D;&gt; int(4) [&quot;e&quot;] &#x3D;&gt; int(5) &#125; array(5) &#123; [&quot;a&quot;] &#x3D;&gt; int(1) [&quot;b&quot;] &#x3D;&gt; int(2) [&quot;c&quot;] &#x3D;&gt; int(3) [&quot;d&quot;] &#x3D;&gt; int(4) [&quot;e&quot;] &#x3D;&gt; int(5) &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/"},{"name":"php","slug":"技术/php","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/php/"}],"tags":[{"name":"json","slug":"json","permalink":"https://loststar.tech/tags/json/"},{"name":"数组","slug":"数组","permalink":"https://loststar.tech/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"应用Travis CI摆脱Hexo博客换机难","slug":"应用Travis-CI摆脱HEXO博客换机难","date":"2017-07-31T04:47:00.000Z","updated":"2021-12-14T15:42:06.085Z","comments":true,"path":"posts/d9cdb463/","link":"","permalink":"https://loststar.tech/posts/d9cdb463/","excerpt":"","text":"一直以来，用Hexo+Github Page写博客都是一种装逼高端的做法。但是，HEXO写博客是生成静态文件再上传。当需要在别的电脑写博客的时候会比较麻烦。所以，现在使用Travis CI来解决这一问题。 获取Personal Access Token1.进入设置 2.点击Personal Access Token 3.点击右上角的Generate new token 4.设置Token description，选择权限 5.点击Generate token 6.复制生成的Personal access tokens（注意：token只会在刚刚创建完成后显示一次，关闭页面后再打开不再显示） 配置Travis CI1.用Github账号登陆Travis CI 2.点击左上角的“+” 3.点击博客源码仓库前面的滑块![open]7.JPG) 4.点击滑块旁边的设置 5.点击Build only if .travis.yml is present前面的滑块 6.在Environment Variables添加你的Personal access tokens 7.点击add 配置仓库文件1.在源码仓库创建.travis.yml 2.在文件内写入信息（以下供参考，更详细请参考Travis CI文档 ) language: node_js node_js: stable # S: Build Lifecycle install: - npm install #before_script: # - npm install -g gulp before_install: - export TZ&#x3D;&#39;Asia&#x2F;Shanghai&#39; # 设置时区 - npm install -g hexo - npm install -g hexo-cli script: - hexo clean - hexo g after_script: - cd .&#x2F;public - git init - git config user.name &quot;你的昵称&quot; - git config user.email &quot;你的邮箱&quot; - git add . - git commit -m &quot;Update docs&quot; - git push --force --quiet &quot;https:&#x2F;&#x2F;$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master # E: Build LifeCycle branches: only: - master env: global: - GH_REF: github.com&#x2F;*******&#x2F;********.github.io.git（Github Page仓库） 最后1.写一篇新文章，push源码到github 2.在Travis CI就可以看到正在构建了（黄色） 3.build passing之后（绿色）就可以在博客网页看到新文章了。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Travis CI","slug":"Travis-CI","permalink":"https://loststar.tech/tags/Travis-CI/"}],"author":"Loststar"},{"title":"Next主题下HyperComments的优化","slug":"Next主题下HyperComments的汉化","date":"2017-07-30T02:59:00.000Z","updated":"2021-12-14T15:45:47.541Z","comments":true,"path":"posts/da438ac2/","link":"","permalink":"https://loststar.tech/posts/da438ac2/","excerpt":"","text":"近日，把博客从typecho换到hexo，没有了typecho的原生评论，便开始寻找第三方评论。我所用的NexT主题比较良心，提供了好几种评论选择。然而，其中有的被墙了（disqus等），有的倒闭了（多说、网易云跟帖等），只剩下LiveRe（棒子国）和HyperComments（毛子国）。然而听说LiveRe口碑不怎么样，所以积极投身HyperComments。 前期准备1.注册HyperComments 2.获取hypercomments_id并填入主题目录下的_config.yml 3.你已经可以开始用HyperComments了 问题在使用过程中，会发现一些问题。比如，评论框文字是繁体，加载比较慢等。 解决js本地化1.下载http://w.hypercomments.com/widget/hc/你的hypercomments_id/zh/widget.js[下文称js1] 2.找到类似h.src=(&quot;https:&quot;==d.location.protocol?&quot;https&quot;:&quot;http&quot;)+&quot;://static.hypercomments.com/widget/hcembed/*****/zh/**************/**************/&quot;+f;的语句（可以搜索src） 3.下载static.hypercomments.com/widget/hcembed/*****/zh/**************/**************/widget.js[下文称js2] 繁体简化1.打开js2 2.找到有繁体字的地方，修改成简体字 3.上传新js2到你的存放空间，并获取新js2的外链地址 4.把js1里src=后面，下一个分号前面换成上一步获得的地址 5.上传新js1到你的空间，获取外链地址 6.打开主题目录下的\\layout\\_third-party\\comments\\hypercomments.swig,把hcc.src =到&quot;;之间内容换成上一步获得的js1的地址 7.重新部署hexo","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"hexo","slug":"博客相关/hexo","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo/"}],"tags":[{"name":"HyperComments","slug":"HyperComments","permalink":"https://loststar.tech/tags/HyperComments/"},{"name":"繁体简化","slug":"繁体简化","permalink":"https://loststar.tech/tags/%E7%B9%81%E4%BD%93%E7%AE%80%E5%8C%96/"}],"author":"loststar"}],"categories":[{"name":"课程作业","slug":"课程作业","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"MIT 6.830","slug":"课程作业/MIT-6-830","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/MIT-6-830/"},{"name":"数据结构","slug":"数据结构","permalink":"https://loststar.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"技术","slug":"技术","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/"},{"name":"项目记录","slug":"技术/项目记录","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"},{"name":"java","slug":"技术/java","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/java/"},{"name":"算法","slug":"算法","permalink":"https://loststar.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"工具分享","slug":"工具分享","permalink":"https://loststar.tech/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"},{"name":"数据结构","slug":"课程作业/数据结构","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"php","slug":"技术/php","permalink":"https://loststar.tech/categories/%E6%8A%80%E6%9C%AF/php/"},{"name":"博客相关","slug":"博客相关","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"hexo","slug":"博客相关/hexo","permalink":"https://loststar.tech/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo/"},{"name":"创新实践课","slug":"课程作业/创新实践课","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%AF%BE/"},{"name":"方法记录","slug":"方法记录","permalink":"https://loststar.tech/categories/%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"},{"name":"操作系统","slug":"课程作业/操作系统","permalink":"https://loststar.tech/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Database Systems","slug":"Database-Systems","permalink":"https://loststar.tech/tags/Database-Systems/"},{"name":"数据库","slug":"数据库","permalink":"https://loststar.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"https://loststar.tech/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"Bloom Filter","slug":"Bloom-Filter","permalink":"https://loststar.tech/tags/Bloom-Filter/"},{"name":"扩容","slug":"扩容","permalink":"https://loststar.tech/tags/%E6%89%A9%E5%AE%B9/"},{"name":"JAVA","slug":"JAVA","permalink":"https://loststar.tech/tags/JAVA/"},{"name":"造轮子","slug":"造轮子","permalink":"https://loststar.tech/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"},{"name":"线程池","slug":"线程池","permalink":"https://loststar.tech/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"参数","slug":"参数","permalink":"https://loststar.tech/tags/%E5%8F%82%E6%95%B0/"},{"name":"jmeter","slug":"jmeter","permalink":"https://loststar.tech/tags/jmeter/"},{"name":"单例模式","slug":"单例模式","permalink":"https://loststar.tech/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"JDK","slug":"JDK","permalink":"https://loststar.tech/tags/JDK/"},{"name":"源码","slug":"源码","permalink":"https://loststar.tech/tags/%E6%BA%90%E7%A0%81/"},{"name":"对象不可变","slug":"对象不可变","permalink":"https://loststar.tech/tags/%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E5%8F%98/"},{"name":"引用不可变","slug":"引用不可变","permalink":"https://loststar.tech/tags/%E5%BC%95%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98/"},{"name":"markdown","slug":"markdown","permalink":"https://loststar.tech/tags/markdown/"},{"name":"marktext","slug":"marktext","permalink":"https://loststar.tech/tags/marktext/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://loststar.tech/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"插入排序","slug":"插入排序","permalink":"https://loststar.tech/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","permalink":"https://loststar.tech/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"插件","slug":"插件","permalink":"https://loststar.tech/tags/%E6%8F%92%E4%BB%B6/"},{"name":"折叠","slug":"折叠","permalink":"https://loststar.tech/tags/%E6%8A%98%E5%8F%A0/"},{"name":"map","slug":"map","permalink":"https://loststar.tech/tags/map/"},{"name":"merge","slug":"merge","permalink":"https://loststar.tech/tags/merge/"},{"name":"剪贴板","slug":"剪贴板","permalink":"https://loststar.tech/tags/%E5%89%AA%E8%B4%B4%E6%9D%BF/"},{"name":"一键保存","slug":"一键保存","permalink":"https://loststar.tech/tags/%E4%B8%80%E9%94%AE%E4%BF%9D%E5%AD%98/"},{"name":"数组","slug":"数组","permalink":"https://loststar.tech/tags/%E6%95%B0%E7%BB%84/"},{"name":"广义表","slug":"广义表","permalink":"https://loststar.tech/tags/%E5%B9%BF%E4%B9%89%E8%A1%A8/"},{"name":"鞍点","slug":"鞍点","permalink":"https://loststar.tech/tags/%E9%9E%8D%E7%82%B9/"},{"name":"稀疏矩阵转置","slug":"稀疏矩阵转置","permalink":"https://loststar.tech/tags/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/"},{"name":"mysql","slug":"mysql","permalink":"https://loststar.tech/tags/mysql/"},{"name":"问题排查","slug":"问题排查","permalink":"https://loststar.tech/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"name":"PDO","slug":"PDO","permalink":"https://loststar.tech/tags/PDO/"},{"name":"方法记录","slug":"方法记录","permalink":"https://loststar.tech/tags/%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"},{"name":"mathjax","slug":"mathjax","permalink":"https://loststar.tech/tags/mathjax/"},{"name":"indigo","slug":"indigo","permalink":"https://loststar.tech/tags/indigo/"},{"name":"预处理","slug":"预处理","permalink":"https://loststar.tech/tags/%E9%A2%84%E5%A4%84%E7%90%86/"},{"name":"PIL","slug":"PIL","permalink":"https://loststar.tech/tags/PIL/"},{"name":"JupyterNotebook","slug":"JupyterNotebook","permalink":"https://loststar.tech/tags/JupyterNotebook/"},{"name":"实验","slug":"实验","permalink":"https://loststar.tech/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"银行家算法","slug":"银行家算法","permalink":"https://loststar.tech/tags/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"},{"name":"豆瓣","slug":"豆瓣","permalink":"https://loststar.tech/tags/%E8%B1%86%E7%93%A3/"},{"name":"apikey","slug":"apikey","permalink":"https://loststar.tech/tags/apikey/"},{"name":"命令解析","slug":"命令解析","permalink":"https://loststar.tech/tags/%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/"},{"name":"shell","slug":"shell","permalink":"https://loststar.tech/tags/shell/"},{"name":"栈","slug":"栈","permalink":"https://loststar.tech/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://loststar.tech/tags/%E9%98%9F%E5%88%97/"},{"name":"停车场","slug":"停车场","permalink":"https://loststar.tech/tags/%E5%81%9C%E8%BD%A6%E5%9C%BA/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"https://loststar.tech/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"name":"N皇后问题","slug":"N皇后问题","permalink":"https://loststar.tech/tags/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"线性表","slug":"线性表","permalink":"https://loststar.tech/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"https://loststar.tech/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"name":"OUTLINE","slug":"OUTLINE","permalink":"https://loststar.tech/tags/OUTLINE/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://loststar.tech/tags/shadowsocks/"},{"name":"github","slug":"github","permalink":"https://loststar.tech/tags/github/"},{"name":"repo","slug":"repo","permalink":"https://loststar.tech/tags/repo/"},{"name":"wordpress","slug":"wordpress","permalink":"https://loststar.tech/tags/wordpress/"},{"name":"hexo","slug":"hexo","permalink":"https://loststar.tech/tags/hexo/"},{"name":"typecho","slug":"typecho","permalink":"https://loststar.tech/tags/typecho/"},{"name":"json","slug":"json","permalink":"https://loststar.tech/tags/json/"},{"name":"Travis CI","slug":"Travis-CI","permalink":"https://loststar.tech/tags/Travis-CI/"},{"name":"HyperComments","slug":"HyperComments","permalink":"https://loststar.tech/tags/HyperComments/"},{"name":"繁体简化","slug":"繁体简化","permalink":"https://loststar.tech/tags/%E7%B9%81%E4%BD%93%E7%AE%80%E5%8C%96/"}]}